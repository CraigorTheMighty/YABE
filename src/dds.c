//#define USE_RGBCX_ENCODER

extern float errsum;

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <conio.h>
#include <commctrl.h>
#include <math.h>
#include <psapi.h>
#include <Dbghelp.h>
#include <inttypes.h>
#include <dxgiformat.h>
#include <ddraw.h>

#include <gl\gl.h>
#include <gl\glu.h>
#include <gl\glext.h>
#include <gl\wglext.h>

#define CL_TARGET_OPENCL_VERSION	200
#define CL_USE_DEPRECATED_OPENCL_1_2_APIS

#define BINARY_FILE_TARGET_ELEMENTS_NO_UUID (28 + 3 * 16)

#define BINARY_FILE_TARGET_BYTES  (16 + BINARY_FILE_TARGET_ELEMENTS_NO_UUID*4)
#define BINARY_FILE_TARGET_ELEMENTS (16 + BINARY_FILE_TARGET_ELEMENTS_NO_UUID)

#include <cl\cl.h>

#include "..\inc\IL\il.h"
#include "..\inc\IL\ilu.h"
#include "..\inc\IL\ilut.h"

#include "../inc/math.h"
#include "../inc/memory.h"
#include "../inc/dds.h"
#include "../inc/system.h"
#include "../inc/timer.h"
#include "../inc/math.h"
#include "../inc/vecmat.h"
#include "../inc/dds_const.h"
#include "../inc/dds_util.h"
#include "../inc/dds.h"
#include "..\inc\image.h"
#include "..\inc\device_codec.h"
#include "../inc/opencl.h"
#include "../inc/rgbcx_c.h"

#define DDS_MAKE_FOURCC(s0, s1, s2, s3)	((s0 << 0) | (s1 << 8) | (s2 << 16) | (s3 << 24))

#define DDS_MAGIC								DDS_MAKE_FOURCC('D', 'D', 'S', ' ')

#define DDS_ALPHA_MODE_STRAIGHT					0x00000001

#define DDS_ALPHAPIXELS                        0x00000001
#define DDS_ALPHA                              0x00000002
#define DDS_FOURCC                             0x00000004
#define DDS_PALETTEINDEXED4                    0x00000008
#define DDS_PALETTEINDEXEDTO8                  0x00000010
#define DDS_PALETTEINDEXED8                    0x00000020
#define DDS_RGB                                0x00000040
#define DDS_COMPRESSED                         0x00000080
#define DDS_RGBTOYUV                           0x00000100
#define DDS_YUV                                0x00000200
#define DDS_ZBUFFER                            0x00000400
#define DDS_PALETTEINDEXED1                    0x00000800
#define DDS_PALETTEINDEXED2                    0x00001000
#define DDS_ZPIXELS                            0x00002000
#define DDS_STENCILBUFFER                      0x00004000
#define DDS_ALPHAPREMULT                       0x00008000
#define DDS_LUMINANCE                          0x00020000
#define DDS_BUMPLUMINANCE                      0x00040000
#define DDS_BUMPDUDV                           0x00080000

typedef enum D3DFORMAT 
{
	D3DFMT_UNKNOWN              =  0,

	D3DFMT_R8G8B8               = 20,
	D3DFMT_A8R8G8B8             = 21,
	D3DFMT_X8R8G8B8             = 22,
	D3DFMT_R5G6B5               = 23,
	D3DFMT_X1R5G5B5             = 24,
	D3DFMT_A1R5G5B5             = 25,
	D3DFMT_A4R4G4B4             = 26,
	D3DFMT_R3G3B2               = 27,
	D3DFMT_A8                   = 28,
	D3DFMT_A8R3G3B2             = 29,
	D3DFMT_X4R4G4B4             = 30,
	D3DFMT_A2B10G10R10          = 31,
	D3DFMT_A8B8G8R8             = 32,
	D3DFMT_X8B8G8R8             = 33,
	D3DFMT_G16R16               = 34,
	D3DFMT_A2R10G10B10          = 35,
	D3DFMT_A16B16G16R16         = 36,

	D3DFMT_A8P8                 = 40,
	D3DFMT_P8                   = 41,

	D3DFMT_L8                   = 50,
	D3DFMT_A8L8                 = 51,
	D3DFMT_A4L4                 = 52,

	D3DFMT_V8U8                 = 60,
	D3DFMT_L6V5U5               = 61,
	D3DFMT_X8L8V8U8             = 62,
	D3DFMT_Q8W8V8U8             = 63,
	D3DFMT_V16U16               = 64,
	D3DFMT_A2W10V10U10          = 67,

	D3DFMT_UYVY                 = DDS_MAKE_FOURCC('U', 'Y', 'V', 'Y'),
	D3DFMT_R8G8_B8G8            = DDS_MAKE_FOURCC('R', 'G', 'B', 'G'),
	D3DFMT_YUY2                 = DDS_MAKE_FOURCC('Y', 'U', 'Y', '2'),
	D3DFMT_G8R8_G8B8            = DDS_MAKE_FOURCC('G', 'R', 'G', 'B'),
	D3DFMT_DXT1                 = DDS_MAKE_FOURCC('D', 'X', 'T', '1'),
	D3DFMT_DXT2                 = DDS_MAKE_FOURCC('D', 'X', 'T', '2'),
	D3DFMT_DXT3                 = DDS_MAKE_FOURCC('D', 'X', 'T', '3'),
	D3DFMT_DXT4                 = DDS_MAKE_FOURCC('D', 'X', 'T', '4'),
	D3DFMT_DXT5                 = DDS_MAKE_FOURCC('D', 'X', 'T', '5'),

	D3DFMT_D16_LOCKABLE         = 70,
	D3DFMT_D32                  = 71,
	D3DFMT_D15S1                = 73,
	D3DFMT_D24S8                = 75,
	D3DFMT_D24X8                = 77,
	D3DFMT_D24X4S4              = 79,
	D3DFMT_D16                  = 80,

	D3DFMT_D32F_LOCKABLE        = 82,
	D3DFMT_D24FS8               = 83,

	D3DFMT_D32_LOCKABLE         = 84,
	D3DFMT_S8_LOCKABLE          = 85,

	D3DFMT_L16                  = 81,

	D3DFMT_VERTEXDATA           = 100,
	D3DFMT_INDEX16              = 101,
	D3DFMT_INDEX32              = 102,

	D3DFMT_Q16W16V16U16         = 110,

	D3DFMT_MULTI2_ARGB8         = DDS_MAKE_FOURCC('M', 'E', 'T', '1'),

	D3DFMT_R16F                 = 111,
	D3DFMT_G16R16F              = 112,
	D3DFMT_A16B16G16R16F        = 113,

	D3DFMT_R32F                 = 114,
	D3DFMT_G32R32F              = 115,
	D3DFMT_A32B32G32R32F        = 116,

	D3DFMT_CxV8U8               = 117,

	D3DFMT_A1                   = 118,
	D3DFMT_A2B10G10R10_XR_BIAS  = 119,
	D3DFMT_BINARYBUFFER         = 199,

	D3DFMT_FORCE_DWORD          = 0x7fffffff
}D3DFORMAT;

typedef struct dds_mixed_fmt_s
{
	int type;
	union
	{
		D3DFORMAT	d3dfmt;
		DXGI_FORMAT	dxgifmt;
	};
}dds_mixed_fmt_t;

typedef struct DDS_PIXELFORMAT
{
	DWORD dwSize;
	DWORD dwFlags;
	DWORD dwFourCC;
	DWORD dwRGBBitCount;
	DWORD dwRBitMask;
	DWORD dwGBitMask;
	DWORD dwBBitMask;
	DWORD dwABitMask;
}DDS_PIXELFORMAT;

typedef enum D3D10_RESOURCE_DIMENSION 
{
	D3D10_RESOURCE_DIMENSION_UNKNOWN = 0,
	D3D10_RESOURCE_DIMENSION_BUFFER = 1,
	D3D10_RESOURCE_DIMENSION_TEXTURE1D = 2,
	D3D10_RESOURCE_DIMENSION_TEXTURE2D = 3,
	D3D10_RESOURCE_DIMENSION_TEXTURE3D = 4
}D3D10_RESOURCE_DIMENSION;

typedef struct dds_header_s
{
	DWORD           dwSize;
	DWORD           dwFlags;
	DWORD           dwHeight;
	DWORD           dwWidth;
	DWORD           dwPitchOrLinearSize;
	DWORD           dwDepth;
	DWORD           dwMipMapCount;
	DWORD           dwReserved1[11];
	DDS_PIXELFORMAT ddspf;
	DWORD           dwCaps;
	DWORD           dwCaps2;
	DWORD           dwCaps3;
	DWORD           dwCaps4;
	DWORD           dwReserved2;
}dds_header_t;

typedef struct dds_header_dxt10_s
{
	DXGI_FORMAT              dxgiFormat;
	D3D10_RESOURCE_DIMENSION resourceDimension;
	UINT                     miscFlag;
	UINT                     arraySize;
	UINT                     miscFlags2;
}dds_header_dxt10_t;
typedef struct dds_s
{
	DWORD				magic;
	dds_header_t		header;
	dds_header_dxt10_t	header_dxt10;
}dds_t;

static uint8_t g_dds_inferno_colourmap[1024][3] = 
{
	{  0,   0,   4}, {  0,   0,   4}, {  0,   0,   4}, {  1,   0,   4}, {  1,   0,   5}, {  1,   0,   5}, {  1,   0,   5}, {  1,   1,   6}, 
	{  1,   1,   6}, {  1,   1,   7}, {  1,   1,   7}, {  1,   1,   7}, {  1,   1,   8}, {  1,   1,   8}, {  1,   1,   9}, {  1,   1,   9}, 
	{  2,   1,  10}, {  2,   1,  10}, {  2,   1,  11}, {  2,   1,  11}, {  2,   2,  12}, {  2,   2,  12}, {  2,   2,  13}, {  2,   2,  14}, 
	{  2,   2,  14}, {  3,   2,  15}, {  3,   2,  15}, {  3,   2,  16}, {  3,   2,  16}, {  3,   3,  17}, {  3,   3,  17}, {  3,   3,  18}, 
	{  4,   3,  18}, {  4,   3,  19}, {  4,   3,  19}, {  4,   3,  20}, {  4,   3,  20}, {  4,   3,  21}, {  5,   4,  22}, {  5,   4,  22}, 
	{  5,   4,  23}, {  5,   4,  23}, {  5,   4,  24}, {  6,   4,  24}, {  6,   4,  25}, {  6,   5,  25}, {  6,   5,  26}, {  6,   5,  26}, 
	{  7,   5,  27}, {  7,   5,  27}, {  7,   5,  28}, {  7,   5,  29}, {  7,   5,  29}, {  8,   6,  30}, {  8,   6,  30}, {  8,   6,  31}, 
	{  8,   6,  31}, {  9,   6,  32}, {  9,   6,  32}, {  9,   6,  33}, { 10,   7,  34}, { 10,   7,  34}, { 10,   7,  35}, { 10,   7,  35}, 
	{ 11,   7,  36}, { 11,   7,  36}, { 11,   7,  37}, { 12,   8,  38}, { 12,   8,  38}, { 12,   8,  39}, { 13,   8,  39}, { 13,   8,  40}, 
	{ 13,   8,  40}, { 13,   8,  41}, { 14,   9,  42}, { 14,   9,  42}, { 14,   9,  43}, { 15,   9,  43}, { 15,   9,  44}, { 15,   9,  45}, 
	{ 16,   9,  45}, { 16,   9,  46}, { 16,  10,  46}, { 17,  10,  47}, { 17,  10,  48}, { 17,  10,  48}, { 17,  10,  49}, { 18,  10,  49}, 
	{ 18,  10,  50}, { 18,  10,  51}, { 19,  10,  51}, { 19,  11,  52}, { 19,  11,  52}, { 20,  11,  53}, { 20,  11,  54}, { 20,  11,  54}, 
	{ 21,  11,  55}, { 21,  11,  55}, { 21,  11,  56}, { 22,  11,  57}, { 22,  11,  57}, { 23,  11,  58}, { 23,  11,  58}, { 23,  12,  59}, 
	{ 24,  12,  60}, { 24,  12,  60}, { 24,  12,  61}, { 25,  12,  61}, { 25,  12,  62}, { 25,  12,  63}, { 26,  12,  63}, { 26,  12,  64}, 
	{ 27,  12,  64}, { 27,  12,  65}, { 27,  12,  66}, { 28,  12,  66}, { 28,  12,  67}, { 28,  12,  67}, { 29,  12,  68}, { 29,  12,  69}, 
	{ 30,  12,  69}, { 30,  12,  70}, { 30,  12,  70}, { 31,  12,  71}, { 31,  12,  72}, { 32,  12,  72}, { 32,  12,  73}, { 32,  12,  73}, 
	{ 33,  12,  74}, { 33,  12,  75}, { 34,  12,  75}, { 34,  12,  76}, { 34,  12,  76}, { 35,  12,  77}, { 35,  12,  77}, { 36,  12,  78}, 
	{ 36,  12,  78}, { 37,  12,  79}, { 37,  12,  80}, { 37,  12,  80}, { 38,  12,  81}, { 38,  12,  81}, { 39,  12,  82}, { 39,  11,  82}, 
	{ 40,  11,  83}, { 40,  11,  83}, { 40,  11,  84}, { 41,  11,  84}, { 41,  11,  85}, { 42,  11,  85}, { 42,  11,  86}, { 43,  11,  86}, 
	{ 43,  11,  87}, { 43,  11,  87}, { 44,  11,  88}, { 44,  11,  88}, { 45,  11,  89}, { 45,  11,  89}, { 46,  10,  89}, { 46,  10,  90}, 
	{ 47,  10,  90}, { 47,  10,  91}, { 47,  10,  91}, { 48,  10,  92}, { 48,  10,  92}, { 49,  10,  92}, { 49,  10,  93}, { 50,  10,  93}, 
	{ 50,  10,  94}, { 51,  10,  94}, { 51,  10,  94}, { 51,  10,  95}, { 52,  10,  95}, { 52,  10,  95}, { 53,  10,  96}, { 53,  10,  96}, 
	{ 54,   9,  96}, { 54,   9,  97}, { 54,   9,  97}, { 55,   9,  97}, { 55,   9,  98}, { 56,   9,  98}, { 56,   9,  98}, { 57,   9,  99}, 
	{ 57,   9,  99}, { 58,   9,  99}, { 58,   9,  99}, { 58,   9, 100}, { 59,   9, 100}, { 59,   9, 100}, { 60,   9, 100}, { 60,   9, 101}, 
	{ 61,   9, 101}, { 61,   9, 101}, { 61,   9, 101}, { 62,   9, 102}, { 62,   9, 102}, { 63,   9, 102}, { 63,  10, 102}, { 63,  10, 103}, 
	{ 64,  10, 103}, { 64,  10, 103}, { 65,  10, 103}, { 65,  10, 103}, { 66,  10, 104}, { 66,  10, 104}, { 66,  10, 104}, { 67,  10, 104}, 
	{ 67,  10, 104}, { 68,  10, 104}, { 68,  10, 105}, { 69,  10, 105}, { 69,  10, 105}, { 69,  10, 105}, { 70,  11, 105}, { 70,  11, 105}, 
	{ 71,  11, 106}, { 71,  11, 106}, { 71,  11, 106}, { 72,  11, 106}, { 72,  11, 106}, { 73,  11, 106}, { 73,  11, 106}, { 73,  11, 107}, 
	{ 74,  12, 107}, { 74,  12, 107}, { 75,  12, 107}, { 75,  12, 107}, { 76,  12, 107}, { 76,  12, 107}, { 76,  12, 107}, { 77,  12, 107}, 
	{ 77,  13, 108}, { 78,  13, 108}, { 78,  13, 108}, { 78,  13, 108}, { 79,  13, 108}, { 79,  13, 108}, { 80,  13, 108}, { 80,  13, 108}, 
	{ 80,  14, 108}, { 81,  14, 108}, { 81,  14, 109}, { 82,  14, 109}, { 82,  14, 109}, { 82,  14, 109}, { 83,  14, 109}, { 83,  15, 109}, 
	{ 84,  15, 109}, { 84,  15, 109}, { 84,  15, 109}, { 85,  15, 109}, { 85,  15, 109}, { 86,  15, 109}, { 86,  15, 109}, { 86,  16, 109}, 
	{ 87,  16, 109}, { 87,  16, 110}, { 88,  16, 110}, { 88,  16, 110}, { 88,  16, 110}, { 89,  17, 110}, { 89,  17, 110}, { 90,  17, 110}, 
	{ 90,  17, 110}, { 90,  17, 110}, { 91,  17, 110}, { 91,  17, 110}, { 92,  18, 110}, { 92,  18, 110}, { 92,  18, 110}, { 93,  18, 110}, 
	{ 93,  18, 110}, { 94,  18, 110}, { 94,  18, 110}, { 94,  19, 110}, { 95,  19, 110}, { 95,  19, 110}, { 96,  19, 110}, { 96,  19, 110}, 
	{ 96,  19, 110}, { 97,  19, 110}, { 97,  20, 110}, { 98,  20, 110}, { 98,  20, 110}, { 98,  20, 110}, { 99,  20, 110}, { 99,  20, 110}, 
	{ 99,  21, 110}, {100,  21, 110}, {100,  21, 110}, {101,  21, 110}, {101,  21, 110}, {101,  21, 110}, {102,  21, 110}, {102,  22, 110}, 
	{103,  22, 110}, {103,  22, 110}, {103,  22, 110}, {104,  22, 110}, {104,  22, 110}, {105,  22, 110}, {105,  23, 110}, {105,  23, 110}, 
	{106,  23, 110}, {106,  23, 110}, {107,  23, 110}, {107,  23, 110}, {107,  23, 110}, {108,  24, 110}, {108,  24, 110}, {109,  24, 110}, 
	{109,  24, 110}, {109,  24, 110}, {110,  24, 110}, {110,  24, 110}, {111,  25, 110}, {111,  25, 110}, {111,  25, 110}, {112,  25, 110}, 
	{112,  25, 110}, {113,  25, 110}, {113,  25, 110}, {113,  26, 110}, {114,  26, 110}, {114,  26, 110}, {115,  26, 110}, {115,  26, 110}, 
	{115,  26, 110}, {116,  26, 110}, {116,  27, 110}, {116,  27, 110}, {117,  27, 110}, {117,  27, 110}, {118,  27, 110}, {118,  27, 110}, 
	{118,  27, 109}, {119,  28, 109}, {119,  28, 109}, {120,  28, 109}, {120,  28, 109}, {120,  28, 109}, {121,  28, 109}, {121,  28, 109}, 
	{122,  29, 109}, {122,  29, 109}, {122,  29, 109}, {123,  29, 109}, {123,  29, 109}, {124,  29, 109}, {124,  29, 109}, {124,  30, 109}, 
	{125,  30, 109}, {125,  30, 109}, {126,  30, 108}, {126,  30, 108}, {126,  30, 108}, {127,  30, 108}, {127,  31, 108}, {128,  31, 108}, 
	{128,  31, 108}, {128,  31, 108}, {129,  31, 108}, {129,  31, 108}, {130,  31, 108}, {130,  32, 108}, {130,  32, 108}, {131,  32, 107}, 
	{131,  32, 107}, {132,  32, 107}, {132,  32, 107}, {132,  32, 107}, {133,  33, 107}, {133,  33, 107}, {134,  33, 107}, {134,  33, 107}, 
	{134,  33, 107}, {135,  33, 107}, {135,  33, 107}, {136,  33, 106}, {136,  34, 106}, {136,  34, 106}, {137,  34, 106}, {137,  34, 106}, 
	{137,  34, 106}, {138,  34, 106}, {138,  34, 106}, {139,  35, 106}, {139,  35, 106}, {139,  35, 105}, {140,  35, 105}, {140,  35, 105}, 
	{141,  35, 105}, {141,  35, 105}, {141,  36, 105}, {142,  36, 105}, {142,  36, 105}, {143,  36, 105}, {143,  36, 104}, {143,  36, 104}, 
	{144,  36, 104}, {144,  37, 104}, {145,  37, 104}, {145,  37, 104}, {145,  37, 104}, {146,  37, 104}, {146,  37, 104}, {147,  37, 103}, 
	{147,  38, 103}, {147,  38, 103}, {148,  38, 103}, {148,  38, 103}, {149,  38, 103}, {149,  38, 103}, {149,  38, 103}, {150,  39, 102}, 
	{150,  39, 102}, {151,  39, 102}, {151,  39, 102}, {151,  39, 102}, {152,  39, 102}, {152,  39, 102}, {153,  40, 101}, {153,  40, 101}, 
	{153,  40, 101}, {154,  40, 101}, {154,  40, 101}, {154,  40, 101}, {155,  40, 101}, {155,  41, 100}, {156,  41, 100}, {156,  41, 100}, 
	{156,  41, 100}, {157,  41, 100}, {157,  41, 100}, {158,  42,  99}, {158,  42,  99}, {158,  42,  99}, {159,  42,  99}, {159,  42,  99}, 
	{160,  42,  99}, {160,  42,  99}, {160,  43,  98}, {161,  43,  98}, {161,  43,  98}, {162,  43,  98}, {162,  43,  98}, {162,  43,  98}, 
	{163,  44,  97}, {163,  44,  97}, {164,  44,  97}, {164,  44,  97}, {164,  44,  97}, {165,  44,  97}, {165,  44,  96}, {165,  45,  96}, 
	{166,  45,  96}, {166,  45,  96}, {167,  45,  96}, {167,  45,  95}, {167,  45,  95}, {168,  46,  95}, {168,  46,  95}, {169,  46,  95}, 
	{169,  46,  95}, {169,  46,  94}, {170,  46,  94}, {170,  47,  94}, {170,  47,  94}, {171,  47,  94}, {171,  47,  93}, {172,  47,  93}, 
	{172,  47,  93}, {172,  48,  93}, {173,  48,  93}, {173,  48,  92}, {174,  48,  92}, {174,  48,  92}, {174,  48,  92}, {175,  49,  92}, 
	{175,  49,  91}, {175,  49,  91}, {176,  49,  91}, {176,  49,  91}, {177,  49,  91}, {177,  50,  90}, {177,  50,  90}, {178,  50,  90}, 
	{178,  50,  90}, {178,  50,  90}, {179,  51,  89}, {179,  51,  89}, {180,  51,  89}, {180,  51,  89}, {180,  51,  89}, {181,  51,  88}, 
	{181,  52,  88}, {181,  52,  88}, {182,  52,  88}, {182,  52,  87}, {183,  52,  87}, {183,  53,  87}, {183,  53,  87}, {184,  53,  87}, 
	{184,  53,  86}, {184,  53,  86}, {185,  54,  86}, {185,  54,  86}, {186,  54,  85}, {186,  54,  85}, {186,  54,  85}, {187,  55,  85}, 
	{187,  55,  85}, {187,  55,  84}, {188,  55,  84}, {188,  55,  84}, {189,  56,  84}, {189,  56,  83}, {189,  56,  83}, {190,  56,  83}, 
	{190,  56,  83}, {190,  57,  82}, {191,  57,  82}, {191,  57,  82}, {191,  57,  82}, {192,  57,  81}, {192,  58,  81}, {192,  58,  81}, 
	{193,  58,  81}, {193,  58,  81}, {194,  59,  80}, {194,  59,  80}, {194,  59,  80}, {195,  59,  80}, {195,  59,  79}, {195,  60,  79}, 
	{196,  60,  79}, {196,  60,  79}, {196,  60,  78}, {197,  61,  78}, {197,  61,  78}, {197,  61,  78}, {198,  61,  77}, {198,  61,  77}, 
	{198,  62,  77}, {199,  62,  77}, {199,  62,  76}, {200,  62,  76}, {200,  63,  76}, {200,  63,  76}, {201,  63,  75}, {201,  63,  75}, 
	{201,  64,  75}, {202,  64,  74}, {202,  64,  74}, {202,  64,  74}, {203,  65,  74}, {203,  65,  73}, {203,  65,  73}, {204,  65,  73}, 
	{204,  66,  73}, {204,  66,  72}, {205,  66,  72}, {205,  66,  72}, {205,  67,  72}, {206,  67,  71}, {206,  67,  71}, {206,  67,  71}, 
	{207,  68,  70}, {207,  68,  70}, {207,  68,  70}, {208,  68,  70}, {208,  69,  69}, {208,  69,  69}, {209,  69,  69}, {209,  69,  69}, 
	{209,  70,  68}, {209,  70,  68}, {210,  70,  68}, {210,  71,  67}, {210,  71,  67}, {211,  71,  67}, {211,  71,  67}, {211,  72,  66}, 
	{212,  72,  66}, {212,  72,  66}, {212,  72,  66}, {213,  73,  65}, {213,  73,  65}, {213,  73,  65}, {214,  74,  64}, {214,  74,  64}, 
	{214,  74,  64}, {214,  74,  64}, {215,  75,  63}, {215,  75,  63}, {215,  75,  63}, {216,  76,  62}, {216,  76,  62}, {216,  76,  62}, 
	{217,  77,  62}, {217,  77,  61}, {217,  77,  61}, {217,  77,  61}, {218,  78,  60}, {218,  78,  60}, {218,  78,  60}, {219,  79,  60}, 
	{219,  79,  59}, {219,  79,  59}, {219,  80,  59}, {220,  80,  58}, {220,  80,  58}, {220,  81,  58}, {221,  81,  58}, {221,  81,  57}, 
	{221,  81,  57}, {221,  82,  57}, {222,  82,  56}, {222,  82,  56}, {222,  83,  56}, {223,  83,  56}, {223,  83,  55}, {223,  84,  55}, 
	{223,  84,  55}, {224,  84,  54}, {224,  85,  54}, {224,  85,  54}, {224,  85,  53}, {225,  86,  53}, {225,  86,  53}, {225,  86,  53}, 
	{226,  87,  52}, {226,  87,  52}, {226,  87,  52}, {226,  88,  51}, {227,  88,  51}, {227,  88,  51}, {227,  89,  51}, {227,  89,  50}, 
	{228,  89,  50}, {228,  90,  50}, {228,  90,  49}, {228,  91,  49}, {229,  91,  49}, {229,  91,  48}, {229,  92,  48}, {229,  92,  48}, 
	{230,  92,  48}, {230,  93,  47}, {230,  93,  47}, {230,  93,  47}, {231,  94,  46}, {231,  94,  46}, {231,  94,  46}, {231,  95,  45}, 
	{231,  95,  45}, {232,  96,  45}, {232,  96,  44}, {232,  96,  44}, {232,  97,  44}, {233,  97,  44}, {233,  97,  43}, {233,  98,  43}, 
	{233,  98,  43}, {233,  98,  42}, {234,  99,  42}, {234,  99,  42}, {234, 100,  41}, {234, 100,  41}, {235, 100,  41}, {235, 101,  41}, 
	{235, 101,  40}, {235, 101,  40}, {235, 102,  40}, {236, 102,  39}, {236, 103,  39}, {236, 103,  39}, {236, 103,  38}, {236, 104,  38}, 
	{237, 104,  38}, {237, 105,  37}, {237, 105,  37}, {237, 105,  37}, {237, 106,  36}, {238, 106,  36}, {238, 106,  36}, {238, 107,  35}, 
	{238, 107,  35}, {238, 108,  35}, {239, 108,  35}, {239, 108,  34}, {239, 109,  34}, {239, 109,  34}, {239, 110,  33}, {240, 110,  33}, 
	{240, 110,  33}, {240, 111,  32}, {240, 111,  32}, {240, 112,  32}, {240, 112,  31}, {241, 112,  31}, {241, 113,  31}, {241, 113,  30}, 
	{241, 114,  30}, {241, 114,  30}, {241, 115,  29}, {242, 115,  29}, {242, 115,  29}, {242, 116,  28}, {242, 116,  28}, {242, 117,  28}, 
	{242, 117,  27}, {243, 117,  27}, {243, 118,  27}, {243, 118,  26}, {243, 119,  26}, {243, 119,  26}, {243, 119,  26}, {244, 120,  25}, 
	{244, 120,  25}, {244, 121,  25}, {244, 121,  24}, {244, 122,  24}, {244, 122,  24}, {244, 122,  23}, {245, 123,  23}, {245, 123,  23}, 
	{245, 124,  22}, {245, 124,  22}, {245, 125,  22}, {245, 125,  21}, {245, 125,  21}, {246, 126,  21}, {246, 126,  20}, {246, 127,  20}, 
	{246, 127,  20}, {246, 128,  19}, {246, 128,  19}, {246, 128,  19}, {246, 129,  18}, {247, 129,  18}, {247, 130,  18}, {247, 130,  17}, 
	{247, 131,  17}, {247, 131,  17}, {247, 131,  16}, {247, 132,  16}, {247, 132,  16}, {247, 133,  15}, {248, 133,  15}, {248, 134,  15}, 
	{248, 134,  14}, {248, 135,  14}, {248, 135,  14}, {248, 135,  13}, {248, 136,  13}, {248, 136,  13}, {248, 137,  12}, {248, 137,  12}, 
	{249, 138,  12}, {249, 138,  12}, {249, 139,  11}, {249, 139,  11}, {249, 139,  11}, {249, 140,  10}, {249, 140,  10}, {249, 141,  10}, 
	{249, 141,  10}, {249, 142,   9}, {249, 142,   9}, {250, 143,   9}, {250, 143,   9}, {250, 144,   8}, {250, 144,   8}, {250, 144,   8}, 
	{250, 145,   8}, {250, 145,   8}, {250, 146,   7}, {250, 146,   7}, {250, 147,   7}, {250, 147,   7}, {250, 148,   7}, {250, 148,   7}, 
	{250, 149,   7}, {251, 149,   6}, {251, 149,   6}, {251, 150,   6}, {251, 150,   6}, {251, 151,   6}, {251, 151,   6}, {251, 152,   6}, 
	{251, 152,   6}, {251, 153,   6}, {251, 153,   6}, {251, 154,   6}, {251, 154,   6}, {251, 155,   6}, {251, 155,   6}, {251, 155,   6}, 
	{251, 156,   6}, {251, 156,   6}, {251, 157,   6}, {251, 157,   7}, {251, 158,   7}, {252, 158,   7}, {252, 159,   7}, {252, 159,   7}, 
	{252, 160,   7}, {252, 160,   8}, {252, 161,   8}, {252, 161,   8}, {252, 162,   8}, {252, 162,   9}, {252, 162,   9}, {252, 163,   9}, 
	{252, 163,   9}, {252, 164,  10}, {252, 164,  10}, {252, 165,  10}, {252, 165,  11}, {252, 166,  11}, {252, 166,  11}, {252, 167,  12}, 
	{252, 167,  12}, {252, 168,  13}, {252, 168,  13}, {252, 169,  13}, {252, 169,  14}, {252, 170,  14}, {252, 170,  15}, {252, 171,  15}, 
	{252, 171,  16}, {252, 172,  16}, {252, 172,  16}, {252, 172,  17}, {252, 173,  17}, {252, 173,  18}, {252, 174,  18}, {252, 174,  19}, 
	{252, 175,  19}, {252, 175,  20}, {252, 176,  20}, {252, 176,  21}, {252, 177,  21}, {252, 177,  22}, {252, 178,  22}, {252, 178,  23}, 
	{252, 179,  23}, {252, 179,  24}, {252, 180,  24}, {252, 180,  25}, {252, 181,  25}, {252, 181,  26}, {251, 182,  26}, {251, 182,  27}, 
	{251, 183,  27}, {251, 183,  28}, {251, 184,  28}, {251, 184,  29}, {251, 185,  29}, {251, 185,  30}, {251, 185,  31}, {251, 186,  31}, 
	{251, 186,  32}, {251, 187,  32}, {251, 187,  33}, {251, 188,  33}, {251, 188,  34}, {251, 189,  34}, {251, 189,  35}, {251, 190,  36}, 
	{251, 190,  36}, {251, 191,  37}, {251, 191,  37}, {250, 192,  38}, {250, 192,  38}, {250, 193,  39}, {250, 193,  40}, {250, 194,  40}, 
	{250, 194,  41}, {250, 195,  41}, {250, 195,  42}, {250, 196,  43}, {250, 196,  43}, {250, 197,  44}, {250, 197,  45}, {250, 198,  45}, 
	{249, 198,  46}, {249, 199,  46}, {249, 199,  47}, {249, 200,  48}, {249, 200,  48}, {249, 201,  49}, {249, 201,  50}, {249, 202,  50}, 
	{249, 202,  51}, {249, 203,  52}, {249, 203,  52}, {248, 204,  53}, {248, 204,  54}, {248, 205,  54}, {248, 205,  55}, {248, 206,  56}, 
	{248, 206,  56}, {248, 207,  57}, {248, 207,  58}, {248, 208,  58}, {248, 208,  59}, {247, 208,  60}, {247, 209,  60}, {247, 209,  61}, 
	{247, 210,  62}, {247, 210,  63}, {247, 211,  63}, {247, 211,  64}, {247, 212,  65}, {247, 212,  65}, {246, 213,  66}, {246, 213,  67}, 
	{246, 214,  68}, {246, 214,  68}, {246, 215,  69}, {246, 215,  70}, {246, 216,  71}, {246, 216,  71}, {246, 217,  72}, {245, 217,  73}, 
	{245, 218,  74}, {245, 218,  75}, {245, 219,  75}, {245, 219,  76}, {245, 220,  77}, {245, 220,  78}, {245, 221,  79}, {244, 221,  79}, 
	{244, 222,  80}, {244, 222,  81}, {244, 223,  82}, {244, 223,  83}, {244, 223,  84}, {244, 224,  85}, {244, 224,  85}, {243, 225,  86}, 
	{243, 225,  87}, {243, 226,  88}, {243, 226,  89}, {243, 227,  90}, {243, 227,  91}, {243, 228,  92}, {243, 228,  93}, {243, 229,  93}, 
	{243, 229,  94}, {242, 230,  95}, {242, 230,  96}, {242, 230,  97}, {242, 231,  98}, {242, 231,  99}, {242, 232, 100}, {242, 232, 101}, 
	{242, 233, 102}, {242, 233, 103}, {242, 234, 104}, {242, 234, 105}, {242, 234, 106}, {242, 235, 107}, {241, 235, 108}, {241, 236, 109}, 
	{241, 236, 110}, {241, 237, 111}, {241, 237, 112}, {241, 237, 113}, {241, 238, 114}, {241, 238, 115}, {241, 239, 116}, {241, 239, 117}, 
	{241, 239, 118}, {241, 240, 119}, {241, 240, 120}, {241, 241, 121}, {242, 241, 122}, {242, 241, 123}, {242, 242, 124}, {242, 242, 125}, 
	{242, 242, 126}, {242, 243, 128}, {242, 243, 129}, {242, 244, 130}, {242, 244, 131}, {242, 244, 132}, {243, 245, 133}, {243, 245, 134}, 
	{243, 245, 135}, {243, 246, 136}, {243, 246, 137}, {243, 246, 138}, {244, 247, 139}, {244, 247, 140}, {244, 247, 141}, {244, 248, 142}, 
	{245, 248, 143}, {245, 248, 144}, {245, 249, 145}, {245, 249, 146}, {246, 249, 147}, {246, 249, 148}, {246, 250, 149}, {246, 250, 150}, 
	{247, 250, 151}, {247, 251, 152}, {247, 251, 153}, {248, 251, 154}, {248, 252, 155}, {248, 252, 155}, {249, 252, 156}, {249, 252, 157}, 
	{249, 253, 158}, {250, 253, 159}, {250, 253, 160}, {250, 254, 161}, {251, 254, 162}, {251, 254, 163}, {252, 254, 164}, {252, 255, 164}
};

#if 1
#define DDS_HALF_SPHERE_MAP_NUM_INDEXES	(256)
static int g_dds_half_sphere_map[DDS_HALF_SPHERE_MAP_NUM_INDEXES][3] = 
{
	{ 0,-4, 1},
	{ 0,-4, 2},
	{ 0,-4, 3},
	{ 0,-3, 1},
	{ 0,-3, 2},
	{ 0,-3, 3},
	{ 0,-3, 4},
	{ 0,-2, 1},
	{ 0,-2, 2},
	{ 0,-2, 3},
	{ 0,-2, 4},
	{ 0,-1, 1},
	{ 0,-1, 2},
	{ 0,-1, 3},
	{ 0,-1, 4},
	{ 0, 0, 0},
	{ 0, 0, 1},
	{ 0, 0, 2},
	{ 0, 0, 3},
	{ 0, 0, 4},
	{ 0, 0, 5},
	{ 0, 1, 0},
	{ 0, 1, 1},
	{ 0, 1, 2},
	{ 0, 1, 3},
	{ 0, 1, 4},
	{ 0, 2, 0},
	{ 0, 2, 1},
	{ 0, 2, 2},
	{ 0, 2, 3},
	{ 0, 2, 4},
	{ 0, 3, 0},
	{ 0, 3, 1},
	{ 0, 3, 2},
	{ 0, 3, 3},
	{ 0, 3, 4},
	{ 0, 4, 0},
	{ 0, 4, 1},
	{ 0, 4, 2},
	{ 0, 4, 3},
	{ 0, 5, 0},
	{ 1,-4,-2},
	{ 1,-4,-1},
	{ 1,-4, 0},
	{ 1,-4, 1},
	{ 1,-4, 2},
	{ 1,-3,-3},
	{ 1,-3,-2},
	{ 1,-3,-1},
	{ 1,-3, 0},
	{ 1,-3, 1},
	{ 1,-3, 2},
	{ 1,-3, 3},
	{ 1,-2,-4},
	{ 1,-2,-3},
	{ 1,-2,-2},
	{ 1,-2,-1},
	{ 1,-2, 0},
	{ 1,-2, 1},
	{ 1,-2, 2},
	{ 1,-2, 3},
	{ 1,-2, 4},
	{ 1,-1,-4},
	{ 1,-1,-3},
	{ 1,-1,-2},
	{ 1,-1,-1},
	{ 1,-1, 0},
	{ 1,-1, 1},
	{ 1,-1, 2},
	{ 1,-1, 3},
	{ 1,-1, 4},
	{ 1, 0,-4},
	{ 1, 0,-3},
	{ 1, 0,-2},
	{ 1, 0,-1},
	{ 1, 0, 0},
	{ 1, 0, 1},
	{ 1, 0, 2},
	{ 1, 0, 3},
	{ 1, 0, 4},
	{ 1, 1,-4},
	{ 1, 1,-3},
	{ 1, 1,-2},
	{ 1, 1,-1},
	{ 1, 1, 0},
	{ 1, 1, 1},
	{ 1, 1, 2},
	{ 1, 1, 3},
	{ 1, 1, 4},
	{ 1, 2,-4},
	{ 1, 2,-3},
	{ 1, 2,-2},
	{ 1, 2,-1},
	{ 1, 2, 0},
	{ 1, 2, 1},
	{ 1, 2, 2},
	{ 1, 2, 3},
	{ 1, 2, 4},
	{ 1, 3,-3},
	{ 1, 3,-2},
	{ 1, 3,-1},
	{ 1, 3, 0},
	{ 1, 3, 1},
	{ 1, 3, 2},
	{ 1, 3, 3},
	{ 1, 4,-2},
	{ 1, 4,-1},
	{ 1, 4, 0},
	{ 1, 4, 1},
	{ 1, 4, 2},
	{ 2,-4,-2},
	{ 2,-4,-1},
	{ 2,-4, 0},
	{ 2,-4, 1},
	{ 2,-4, 2},
	//{ 2,-3,-3},
	{ 2,-3,-2},
	{ 2,-3,-1},
	{ 2,-3, 0},
	{ 2,-3, 1},
	{ 2,-3, 2},
	{ 2,-3, 3},
	{ 2,-2,-4},
	{ 2,-2,-3},
	{ 2,-2,-2},
	{ 2,-2,-1},
	{ 2,-2, 0},
	{ 2,-2, 1},
	{ 2,-2, 2},
	{ 2,-2, 3},
	{ 2,-2, 4},
	{ 2,-1,-4},
	{ 2,-1,-3},
	{ 2,-1,-2},
	{ 2,-1,-1},
	{ 2,-1, 0},
	{ 2,-1, 1},
	{ 2,-1, 2},
	{ 2,-1, 3},
	{ 2,-1, 4},
	{ 2, 0,-4},
	{ 2, 0,-3},
	{ 2, 0,-2},
	{ 2, 0,-1},
	{ 2, 0, 0},
	{ 2, 0, 1},
	{ 2, 0, 2},
	{ 2, 0, 3},
	{ 2, 0, 4},
	{ 2, 1,-4},
	{ 2, 1,-3},
	{ 2, 1,-2},
	{ 2, 1,-1},
	{ 2, 1, 0},
	{ 2, 1, 1},
	{ 2, 1, 2},
	{ 2, 1, 3},
	{ 2, 1, 4},
	{ 2, 2,-4},
	{ 2, 2,-3},
	{ 2, 2,-2},
	{ 2, 2,-1},
	{ 2, 2, 0},
	{ 2, 2, 1},
	{ 2, 2, 2},
	{ 2, 2, 3},
	{ 2, 2, 4},
	{ 2, 3,-3},
	{ 2, 3,-2},
	{ 2, 3,-1},
	{ 2, 3, 0},
	{ 2, 3, 1},
	{ 2, 3, 2},
	//{ 2, 3, 3},
	{ 2, 4,-2},
	{ 2, 4,-1},
	{ 2, 4, 0},
	{ 2, 4, 1},
	{ 2, 4, 2},
	{ 3,-4, 0},
	{ 3,-3,-2},
	{ 3,-3,-1},
	{ 3,-3, 0},
	{ 3,-3, 1},
	{ 3,-3, 2},
	{ 3,-2,-3},
	{ 3,-2,-2},
	{ 3,-2,-1},
	{ 3,-2, 0},
	{ 3,-2, 1},
	{ 3,-2, 2},
	{ 3,-2, 3},
	{ 3,-1,-3},
	{ 3,-1,-2},
	{ 3,-1,-1},
	{ 3,-1, 0},
	{ 3,-1, 1},
	{ 3,-1, 2},
	{ 3,-1, 3},
	{ 3, 0,-4},
	{ 3, 0,-3},
	{ 3, 0,-2},
	{ 3, 0,-1},
	{ 3, 0, 0},
	{ 3, 0, 1},
	{ 3, 0, 2},
	{ 3, 0, 3},
	{ 3, 0, 4},
	{ 3, 1,-3},
	{ 3, 1,-2},
	{ 3, 1,-1},
	{ 3, 1, 0},
	{ 3, 1, 1},
	{ 3, 1, 2},
	{ 3, 1, 3},
	{ 3, 2,-3},
	{ 3, 2,-2},
	{ 3, 2,-1},
	{ 3, 2, 0},
	{ 3, 2, 1},
	{ 3, 2, 2},
	{ 3, 2, 3},
	{ 3, 3,-2},
	{ 3, 3,-1},
	{ 3, 3, 0},
	{ 3, 3, 1},
	{ 3, 3, 2},
	{ 3, 4, 0},
	{ 4,-3, 0},
	{ 4,-2,-2},
	{ 4,-2,-1},
	{ 4,-2, 0},
	{ 4,-2, 1},
	{ 4,-2, 2},
	{ 4,-1,-2},
	{ 4,-1,-1},
	{ 4,-1, 0},
	{ 4,-1, 1},
	{ 4,-1, 2},
	{ 4, 0,-3},
	{ 4, 0,-2},
	{ 4, 0,-1},
	{ 4, 0, 0},
	{ 4, 0, 1},
	{ 4, 0, 2},
	{ 4, 0, 3},
	{ 4, 1,-2},
	{ 4, 1,-1},
	{ 4, 1, 0},
	{ 4, 1, 1},
	{ 4, 1, 2},
	{ 4, 2,-2},
	{ 4, 2,-1},
	{ 4, 2, 0},
	{ 4, 2, 1},
	{ 4, 2, 2},
	{ 4, 3, 0},
	{ 5, 0, 0}
};
#else
#if 1
#define DDS_HALF_SPHERE_MAP_NUM_INDEXES	(247 - 4)
static int g_dds_half_sphere_map[DDS_HALF_SPHERE_MAP_NUM_INDEXES][3] = 
{
	{-4,-2, 1},
	{-4,-2, 2},
	{-4,-1, 1},
	{-4,-1, 2},
	{-4, 0, 1},
	{-4, 0, 2},
	{-4, 1, 1},
	{-4, 1, 2},
	{-4, 2, 1},
	{-4, 2, 2},
	{-3,-3, 1},
	{-3,-3, 2},
	{-3,-2, 1},
	{-3,-2, 2},
	{-3,-2, 3},
	{-3,-1, 1},
	{-3,-1, 2},
	{-3,-1, 3},
	{-3, 0, 1},
	{-3, 0, 2},
	{-3, 0, 3},
	{-3, 1, 1},
	{-3, 1, 2},
	{-3, 1, 3},
	{-3, 2, 1},
	{-3, 2, 2},
	{-3, 2, 3},
	{-3, 3, 1},
	{-3, 3, 2},
	{-2,-4, 1},
	{-2,-4, 2},
	{-2,-3, 1},
	{-2,-3, 2},
	{-2,-3, 3},
	{-2,-2, 1},
	{-2,-2, 2},
	{-2,-2, 3},
	{-2,-2, 4},
	{-2,-1, 1},
	{-2,-1, 2},
	{-2,-1, 3},
	{-2,-1, 4},
	{-2, 0, 1},
	{-2, 0, 2},
	{-2, 0, 3},
	{-2, 0, 4},
	{-2, 1, 1},
	{-2, 1, 2},
	{-2, 1, 3},
	{-2, 1, 4},
	{-2, 2, 1},
	{-2, 2, 2},
	{-2, 2, 3},
	{-2, 2, 4},
	{-2, 3, 1},
	{-2, 3, 2},
	{-2, 3, 3},
	{-2, 4, 1},
	{-2, 4, 2},
	{-1,-4, 1},
	{-1,-4, 2},
	{-1,-3, 1},
	{-1,-3, 2},
	{-1,-3, 3},
	{-1,-2, 1},
	{-1,-2, 2},
	{-1,-2, 3},
	{-1,-2, 4},
	{-1,-1, 1},
	{-1,-1, 2},
	{-1,-1, 3},
	{-1,-1, 4},
	{-1, 0, 1},
	{-1, 0, 2},
	{-1, 0, 3},
	{-1, 0, 4},
	{-1, 1, 1},
	{-1, 1, 2},
	{-1, 1, 3},
	{-1, 1, 4},
	{-1, 2, 1},
	{-1, 2, 2},
	{-1, 2, 3},
	{-1, 2, 4},
	{-1, 3, 1},
	{-1, 3, 2},
	{-1, 3, 3},
	{-1, 4, 1},
	{-1, 4, 2},
	//{ 0,-4, 0},
	{ 0,-4, 1},
	{ 0,-4, 2},
	//{ 0,-3, 0},
	{ 0,-3, 1},
	{ 0,-3, 2},
	{ 0,-3, 3},
	//{ 0,-2, 0},
	{ 0,-2, 1},
	{ 0,-2, 2},
	{ 0,-2, 3},
	{ 0,-2, 4},
	//{ 0,-1, 0},
	{ 0,-1, 1},
	{ 0,-1, 2},
	{ 0,-1, 3},
	{ 0,-1, 4},
	{ 0, 0, 0},
	{ 0, 0, 1},
	{ 0, 0, 2},
	{ 0, 0, 3},
	{ 0, 0, 4},
	{ 0, 1, 0},
	{ 0, 1, 1},
	{ 0, 1, 2},
	{ 0, 1, 3},
	{ 0, 1, 4},
	{ 0, 2, 0},
	{ 0, 2, 1},
	{ 0, 2, 2},
	{ 0, 2, 3},
	{ 0, 2, 4},
	{ 0, 3, 0},
	{ 0, 3, 1},
	{ 0, 3, 2},
	{ 0, 3, 3},
	{ 0, 4, 0},
	{ 0, 4, 1},
	{ 0, 4, 2},
	{ 1,-4, 0},
	{ 1,-4, 1},
	{ 1,-4, 2},
	{ 1,-3, 0},
	{ 1,-3, 1},
	{ 1,-3, 2},
	{ 1,-3, 3},
	{ 1,-2, 0},
	{ 1,-2, 1},
	{ 1,-2, 2},
	{ 1,-2, 3},
	{ 1,-2, 4},
	{ 1,-1, 0},
	{ 1,-1, 1},
	{ 1,-1, 2},
	{ 1,-1, 3},
	{ 1,-1, 4},
	{ 1, 0, 0},
	{ 1, 0, 1},
	{ 1, 0, 2},
	{ 1, 0, 3},
	{ 1, 0, 4},
	{ 1, 1, 0},
	{ 1, 1, 1},
	{ 1, 1, 2},
	{ 1, 1, 3},
	{ 1, 1, 4},
	{ 1, 2, 0},
	{ 1, 2, 1},
	{ 1, 2, 2},
	{ 1, 2, 3},
	{ 1, 2, 4},
	{ 1, 3, 0},
	{ 1, 3, 1},
	{ 1, 3, 2},
	{ 1, 3, 3},
	{ 1, 4, 0},
	{ 1, 4, 1},
	{ 1, 4, 2},
	{ 2,-4, 0},
	{ 2,-4, 1},
	{ 2,-4, 2},
	{ 2,-3, 0},
	{ 2,-3, 1},
	{ 2,-3, 2},
	{ 2,-3, 3},
	{ 2,-2, 0},
	{ 2,-2, 1},
	{ 2,-2, 2},
	{ 2,-2, 3},
	{ 2,-2, 4},
	{ 2,-1, 0},
	{ 2,-1, 1},
	{ 2,-1, 2},
	{ 2,-1, 3},
	{ 2,-1, 4},
	{ 2, 0, 0},
	{ 2, 0, 1},
	{ 2, 0, 2},
	{ 2, 0, 3},
	{ 2, 0, 4},
	{ 2, 1, 0},
	{ 2, 1, 1},
	{ 2, 1, 2},
	{ 2, 1, 3},
	{ 2, 1, 4},
	{ 2, 2, 0},
	{ 2, 2, 1},
	{ 2, 2, 2},
	{ 2, 2, 3},
	{ 2, 2, 4},
	{ 2, 3, 0},
	{ 2, 3, 1},
	{ 2, 3, 2},
	{ 2, 3, 3},
	{ 2, 4, 0},
	{ 2, 4, 1},
	{ 2, 4, 2},
	{ 3,-3, 0},
	{ 3,-3, 1},
	{ 3,-3, 2},
	{ 3,-2, 0},
	{ 3,-2, 1},
	{ 3,-2, 2},
	{ 3,-2, 3},
	{ 3,-1, 0},
	{ 3,-1, 1},
	{ 3,-1, 2},
	{ 3,-1, 3},
	{ 3, 0, 0},
	{ 3, 0, 1},
	{ 3, 0, 2},
	{ 3, 0, 3},
	{ 3, 1, 0},
	{ 3, 1, 1},
	{ 3, 1, 2},
	{ 3, 1, 3},
	{ 3, 2, 0},
	{ 3, 2, 1},
	{ 3, 2, 2},
	{ 3, 2, 3},
	{ 3, 3, 0},
	{ 3, 3, 1},
	{ 3, 3, 2},
	{ 4,-2, 0},
	{ 4,-2, 1},
	{ 4,-2, 2},
	{ 4,-1, 0},
	{ 4,-1, 1},
	{ 4,-1, 2},
	{ 4, 0, 0},
	{ 4, 0, 1},
	{ 4, 0, 2},
	{ 4, 1, 0},
	{ 4, 1, 1},
	{ 4, 1, 2},
	{ 4, 2, 0},
	{ 4, 2, 1},
	{ 4, 2, 2}
};
#else
#define DDS_HALF_SPHERE_MAP_NUM_INDEXES 253
static int g_dds_half_sphere_map[253][3] = 
{
	{-4, -2,  0}, 
	{-4, -2,  1}, 
	{-4, -1,  0}, 
	{-4, -1,  1}, 
	{-4, -1,  2}, 
	{-4,  0,  0}, 
	{-4,  0,  1}, 
	{-4,  0,  2}, 
	{-4,  1,  0}, 
	{-4,  1,  1}, 
	{-4,  1,  2}, 
	{-4,  2,  0}, 
	{-4,  2,  1}, 
	{-3, -3,  0}, 
	{-3, -3,  1}, 
	{-3, -2,  0}, 
	{-3, -2,  1}, 
	{-3, -2,  2}, 
	{-3, -1,  0}, 
	{-3, -1,  1}, 
	{-3, -1,  2}, 
	{-3, -1,  3}, 
	{-3,  0,  0}, 
	{-3,  0,  1}, 
	{-3,  0,  2}, 
	{-3,  0,  3}, 
	{-3,  1,  0}, 
	{-3,  1,  1}, 
	{-3,  1,  2}, 
	{-3,  1,  3}, 
	{-3,  2,  0}, 
	{-3,  2,  1}, 
	{-3,  2,  2}, 
	{-3,  3,  0}, 
	{-3,  3,  1}, 
	{-2, -4,  0}, 
	{-2, -4,  1}, 
	{-2, -3,  0}, 
	{-2, -3,  1}, 
	{-2, -3,  2}, 
	{-2, -2,  0}, 
	{-2, -2,  1}, 
	{-2, -2,  2}, 
	{-2, -2,  3}, 
	{-2, -1,  0}, 
	{-2, -1,  1}, 
	{-2, -1,  2}, 
	{-2, -1,  3}, 
	{-2, -1,  4}, 
	{-2,  0,  0}, 
	{-2,  0,  1}, 
	{-2,  0,  2}, 
	{-2,  0,  3}, 
	{-2,  0,  4}, 
	{-2,  1,  0}, 
	{-2,  1,  1}, 
	{-2,  1,  2}, 
	{-2,  1,  3}, 
	{-2,  1,  4}, 
	{-2,  2,  0}, 
	{-2,  2,  1}, 
	{-2,  2,  2}, 
	{-2,  2,  3}, 
	{-2,  3,  0}, 
	{-2,  3,  1}, 
	{-2,  3,  2}, 
	{-2,  4,  0}, 
	{-2,  4,  1}, 
	{-1, -4,  0}, 
	{-1, -4,  1}, 
	{-1, -4,  2}, 
	{-1, -3,  0}, 
	{-1, -3,  1}, 
	{-1, -3,  2}, 
	{-1, -3,  3}, 
	{-1, -2,  0}, 
	{-1, -2,  1}, 
	{-1, -2,  2}, 
	{-1, -2,  3}, 
	{-1, -2,  4}, 
	{-1, -1,  0}, 
	{-1, -1,  1}, 
	{-1, -1,  2}, 
	{-1, -1,  3}, 
	{-1, -1,  4}, 
	{-1,  0,  0}, 
	{-1,  0,  1}, 
	{-1,  0,  2}, 
	{-1,  0,  3}, 
	{-1,  0,  4}, 
	{-1,  1,  0}, 
	{-1,  1,  1}, 
	{-1,  1,  2}, 
	{-1,  1,  3}, 
	{-1,  1,  4}, 
	{-1,  2,  0}, 
	{-1,  2,  1}, 
	{-1,  2,  2}, 
	{-1,  2,  3}, 
	{-1,  2,  4}, 
	{-1,  3,  0}, 
	{-1,  3,  1}, 
	{-1,  3,  2}, 
	{-1,  3,  3}, 
	{-1,  4,  0}, 
	{-1,  4,  1}, 
	{-1,  4,  2}, 
	{ 0, -4,  0}, 
	{ 0, -4,  1}, 
	{ 0, -4,  2}, 
	{ 0, -3,  0}, 
	{ 0, -3,  1}, 
	{ 0, -3,  2}, 
	{ 0, -3,  3}, 
	{ 0, -2,  0}, 
	{ 0, -2,  1}, 
	{ 0, -2,  2}, 
	{ 0, -2,  3}, 
	{ 0, -2,  4}, 
	{ 0, -1,  0}, 
	{ 0, -1,  1}, 
	{ 0, -1,  2}, 
	{ 0, -1,  3}, 
	{ 0, -1,  4}, 
	{ 0,  0,  0}, 
	{ 0,  0,  1}, 
	{ 0,  0,  2}, 
	{ 0,  0,  3}, 
	{ 0,  0,  4}, 
	{ 0,  1,  0}, 
	{ 0,  1,  1}, 
	{ 0,  1,  2}, 
	{ 0,  1,  3}, 
	{ 0,  1,  4}, 
	{ 0,  2,  0}, 
	{ 0,  2,  1}, 
	{ 0,  2,  2}, 
	{ 0,  2,  3}, 
	{ 0,  2,  4}, 
	{ 0,  3,  0}, 
	{ 0,  3,  1}, 
	{ 0,  3,  2}, 
	{ 0,  3,  3}, 
	{ 0,  4,  0}, 
	{ 0,  4,  1}, 
	{ 0,  4,  2}, 
	{ 1, -4,  0}, 
	{ 1, -4,  1}, 
	{ 1, -4,  2}, 
	{ 1, -3,  0}, 
	{ 1, -3,  1}, 
	{ 1, -3,  2}, 
	{ 1, -3,  3}, 
	{ 1, -2,  0}, 
	{ 1, -2,  1}, 
	{ 1, -2,  2}, 
	{ 1, -2,  3}, 
	{ 1, -2,  4}, 
	{ 1, -1,  0}, 
	{ 1, -1,  1}, 
	{ 1, -1,  2}, 
	{ 1, -1,  3}, 
	{ 1, -1,  4}, 
	{ 1,  0,  0}, 
	{ 1,  0,  1}, 
	{ 1,  0,  2}, 
	{ 1,  0,  3}, 
	{ 1,  0,  4}, 
	{ 1,  1,  0}, 
	{ 1,  1,  1}, 
	{ 1,  1,  2}, 
	{ 1,  1,  3}, 
	{ 1,  1,  4}, 
	{ 1,  2,  0}, 
	{ 1,  2,  1}, 
	{ 1,  2,  2}, 
	{ 1,  2,  3}, 
	{ 1,  2,  4}, 
	{ 1,  3,  0}, 
	{ 1,  3,  1}, 
	{ 1,  3,  2}, 
	{ 1,  3,  3}, 
	{ 1,  4,  0}, 
	{ 1,  4,  1}, 
	{ 1,  4,  2}, 
	{ 2, -4,  0}, 
	{ 2, -4,  1}, 
	{ 2, -3,  0}, 
	{ 2, -3,  1}, 
	{ 2, -3,  2}, 
	{ 2, -2,  0}, 
	{ 2, -2,  1}, 
	{ 2, -2,  2}, 
	{ 2, -2,  3}, 
	{ 2, -1,  0}, 
	{ 2, -1,  1}, 
	{ 2, -1,  2}, 
	{ 2, -1,  3}, 
	{ 2, -1,  4}, 
	{ 2,  0,  0}, 
	{ 2,  0,  1}, 
	{ 2,  0,  2}, 
	{ 2,  0,  3}, 
	{ 2,  0,  4}, 
	{ 2,  1,  0}, 
	{ 2,  1,  1}, 
	{ 2,  1,  2}, 
	{ 2,  1,  3}, 
	{ 2,  1,  4}, 
	{ 2,  2,  0}, 
	{ 2,  2,  1}, 
	{ 2,  2,  2}, 
	{ 2,  2,  3}, 
	{ 2,  3,  0}, 
	{ 2,  3,  1}, 
	{ 2,  3,  2}, 
	{ 2,  4,  0}, 
	{ 2,  4,  1}, 
	{ 3, -3,  0}, 
	{ 3, -3,  1}, 
	{ 3, -2,  0}, 
	{ 3, -2,  1}, 
	{ 3, -2,  2}, 
	{ 3, -1,  0}, 
	{ 3, -1,  1}, 
	{ 3, -1,  2}, 
	{ 3, -1,  3}, 
	{ 3,  0,  0}, 
	{ 3,  0,  1}, 
	{ 3,  0,  2}, 
	{ 3,  0,  3}, 
	{ 3,  1,  0}, 
	{ 3,  1,  1}, 
	{ 3,  1,  2}, 
	{ 3,  1,  3}, 
	{ 3,  2,  0}, 
	{ 3,  2,  1}, 
	{ 3,  2,  2}, 
	{ 3,  3,  0}, 
	{ 3,  3,  1}, 
	{ 4, -2,  0}, 
	{ 4, -2,  1}, 
	{ 4, -1,  0}, 
	{ 4, -1,  1}, 
	{ 4, -1,  2}, 
	{ 4,  0,  0}, 
	{ 4,  0,  1}, 
	{ 4,  0,  2}, 
	{ 4,  1,  0}, 
	{ 4,  1,  1}, 
	{ 4,  1,  2}, 
	{ 4,  2,  0}, 
	{ 4,  2,  1}
};
#endif
#endif

int DDS_BlockSize(int format)
{
    switch (format)
    {
		case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:   // BC1
		case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:  // BC1
		case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:  // BC1
		case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: // BC1
		case GL_COMPRESSED_RED_RGTC1:           // BC4
		//case GL_COMPRESSED_SIGNED_RED_RGTC1:    // BC4
			return 8;
		case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:  // BC2
		case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: // BC2
		case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:  // BC3
		case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: // BC3
		case GL_COMPRESSED_RG_RGTC2:            // BC5
		//case GL_COMPRESSED_SIGNED_RG_RGTC2:     // BC5
		//case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: // BC6
		//case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: // BC6
		//case GL_COMPRESSED_RGBA_BPTC_UNORM:     // BC7
		//case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM: // BC7
			return 16;
		default:
			return -1;
    }
}

int EncodeDDSCPU(
    uint8_t **block, 
    float *pixel4x4_rgba, 
    int format,
    int width, 
    int height, 
    float alpha_cutoff)
{
	int block_size;
	int blocks_x;
	int blocks_y;
	int x;
	int y;

#ifdef USE_RGBCX_ENCODER
	RGBCX_Init();
#endif
	
	alpha_cutoff = Math_Clampf32(alpha_cutoff, 0.0f, 255.0f);

	block_size = DDS_BlockSize(format);

	if (block_size < 0)
	{
		ALWAYS_PRINT("Invalid format.\n");
		return -1;
	}

	blocks_x = (width + 3) >> 2;
	blocks_y = (height + 3) >> 2;

	LOG_PRINT("Allocating %i bytes\n", blocks_x * blocks_y * block_size);
	LOG_PRINT("%i x %i = %i x %i blocks\n", width, height, blocks_x, blocks_y);

	*block = Mem_Malloc(blocks_x * blocks_y * block_size);

#ifndef USE_RGBCX_ENCODER
#if USE_OPENMP
#pragma omp parallel for private(y) private(x)
#endif
#endif
	for (y = 0; y < blocks_y; y++)
	{
#if USE_OPENMP
//#pragma omp parallel for private(x)
#endif
		for (x = 0; x < blocks_x; x++)
		{
			int i, j, k;
			uint8_t local_block[16];
			double pixel_rgbaf64[64];
			const int local_width = (int)(width - x * 4 < 4 ? width - x * 4 : 4);
			const int local_height = (int)(height - y * 4 < 4 ? height - y * 4 : 4);

			for (i = 0; i < 4; i++)
				for (j = 0; j < 4; j++)
					for (k = 0; k < 4; k++)
						pixel_rgbaf64[(i*4 + j)*4 + k] = pixel4x4_rgba[(y*4 + (i % local_height))*width*4 + (x*4 + (j % local_width))*4 + k];

			switch(format)
			{
				case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:   // BC1
				case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:  // BC1
#ifdef USE_RGBCX_ENCODER
					RGBCX_EncodeBC1(local_block, pixel_rgbaf64, x, y);
#else
					DDS_EncodeBC1Block(local_block, pixel_rgbaf64, 0, 0, 0, x, y, (uint8_t)0, 0);
#endif
					break;
				case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:  // BC1
				case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: // BC1
#ifdef USE_RGBCX_ENCODER
					RGBCX_EncodeBC1(local_block, pixel_rgbaf64, x, y);
#else
					DDS_EncodeBC1Block(local_block, pixel_rgbaf64, 0, 0, 0, x, y, (uint8_t)alpha_cutoff, 0);
#endif
					break;
				case GL_COMPRESSED_RED_RGTC1:           // BC4
#ifdef USE_RGBCX_ENCODER
					RGBCX_EncodeBC4(local_block, pixel_rgbaf64, x, y);
#else
					DDS_EncodeBC4Block(local_block, pixel_rgbaf64, 0, 0, 0, x, y);
#endif
					break;
				case GL_COMPRESSED_SIGNED_RED_RGTC1:    // BC4
#ifdef USE_RGBCX_ENCODER
					RGBCX_EncodeBC4(local_block, pixel_rgbaf64, x, y);
#else
					DDS_EncodeBC4Block(local_block, pixel_rgbaf64, 0, 0, 1, x, y);
#endif
					break;
				case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:  // BC2
				case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: // BC2
					DDS_EncodeBC2Block(local_block, pixel_rgbaf64, 0, 0, 0, x, y);
					break;
				case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:  // BC3
				case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: // BC3
					DDS_EncodeBC3Block(local_block, pixel_rgbaf64, 0, 0, 0, x, y);
					break;
				case GL_COMPRESSED_RG_RGTC2:            // BC5
				case GL_COMPRESSED_SIGNED_RG_RGTC2:     // BC5
					DDS_EncodeBC5Block(local_block, pixel_rgbaf64, 0, 0, format == GL_COMPRESSED_RG_RGTC2 ? 0 : 1, x, y);
					break;
				case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: // BC6
				case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: // BC6
					DDS_EncodeBC6HBlockf32(local_block, pixel_rgbaf64, 0, 0, format == GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT ? 0 : 1, x, y);
					break;
				case GL_COMPRESSED_RGBA_BPTC_UNORM:     // BC7
				case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM: // BC7
					DDS_EncodeBC7Blockf32(local_block, pixel_rgbaf64, 0, 0, 0, x, y);
					break;
			}

			memcpy(&(*block)[(y * blocks_x + x) * block_size], local_block, block_size);

			System_AddProgress(1, 1);
		}
	}
	return 0;
}








DWORD DDS_GLFormatToDXFormat(int format)
{
	switch(format)
	{
		case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:   // BC1
			return DXGI_FORMAT_BC1_UNORM;
		case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:  // BC1
			return DXGI_FORMAT_BC1_UNORM_SRGB;
		case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:  // BC1
			return DXGI_FORMAT_BC1_UNORM;
		case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: // BC1
			return DXGI_FORMAT_BC1_UNORM_SRGB;
		case GL_COMPRESSED_RED_RGTC1:           // BC4
			return DXGI_FORMAT_BC4_UNORM;
		case GL_COMPRESSED_SIGNED_RED_RGTC1:    // BC4
			return DXGI_FORMAT_BC4_SNORM;
		case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:  // BC2
			return DXGI_FORMAT_BC2_UNORM;
		case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: // BC2
			return DXGI_FORMAT_BC2_UNORM_SRGB;
		case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:  // BC3
			return DXGI_FORMAT_BC3_UNORM;
		case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: // BC3
			return DXGI_FORMAT_BC3_UNORM_SRGB;
		case GL_COMPRESSED_RG_RGTC2:            // BC5
			return DXGI_FORMAT_BC5_UNORM;
		case GL_COMPRESSED_SIGNED_RG_RGTC2:     // BC5
			return DXGI_FORMAT_BC5_SNORM;
		//case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: // BC6
		//case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: // BC6
		//case GL_COMPRESSED_RGBA_BPTC_UNORM:     // BC7
		//case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM: // BC7
			//DDS_EncodeBC7Blockf32(local_block, pixel_rgbaf64, 0, 0, 0, x, y);
			//break;
		default:
			return 0;
	}
}

int DDS_GLFormatIsDX9(int format)
{
	switch(format)
	{
		case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:   // BC1
		case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:  // BC1
		case GL_COMPRESSED_RED_RGTC1:           // BC4
		case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:  // BC2
		case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:  // BC3
		case GL_COMPRESSED_RG_RGTC2:            // BC5
			return 1;
		default:
			return 0;
	}
}
DWORD DDS_GLFormatToDX9(int format)
{
	switch(format)
	{
		case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:   // BC1
		case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:  // BC1
			return DDS_MAKE_FOURCC('D', 'X', 'T', '1');
		case GL_COMPRESSED_RED_RGTC1:           // BC4
			return DDS_MAKE_FOURCC('B', 'C', '4', 'U');
		case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:  // BC2
			return DDS_MAKE_FOURCC('D', 'X', 'T', '3');
		case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:  // BC3
			return DDS_MAKE_FOURCC('D', 'X', 'T', '5');
		case GL_COMPRESSED_RG_RGTC2:            // BC5
			return DDS_MAKE_FOURCC('A', 'T', 'I', '2');
		default:
			return 0;
	}
}

int DDS_SaveDDS(char *output_name, int format)
{
	int i;
	dds_t dds;
	FILE *f;

	dds.magic = DDS_MAGIC;

	dds.header.dwSize = 124;
	dds.header.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_LINEARSIZE;
	if (g_system.num_mipmap_levels > 1)
		dds.header.dwFlags |= DDSD_MIPMAPCOUNT;
	dds.header.dwHeight = g_system.image[0].height;
	dds.header.dwWidth = g_system.image[0].width;
	dds.header.dwPitchOrLinearSize = DDS_BlockSize(format) * ((dds.header.dwWidth + 3) >> 2) * ((dds.header.dwHeight + 3) >> 2);
	dds.header.dwDepth = 1;
	dds.header.dwMipMapCount = g_system.num_mipmap_levels;
	memset(dds.header.dwReserved1, 0, sizeof(DWORD) * 11);

	dds.header.ddspf.dwSize = 32;
	dds.header.ddspf.dwFlags = DDPF_FOURCC;
	if (DDS_GLFormatIsDX9(format))
		dds.header.ddspf.dwFourCC = DDS_GLFormatToDX9(format);
	else
		dds.header.ddspf.dwFourCC = DDS_MAKE_FOURCC('D', 'X', '1', '0');
	/*
	dds.header.ddspf.dwRGBBitCount = 8;
	dds.header.ddspf.dwRBitMask = 0x000000FF;
	dds.header.ddspf.dwGBitMask = 0x0000FF00;
	dds.header.ddspf.dwBBitMask = 0x00FF0000;
	dds.header.ddspf.dwABitMask = 0xFF000000;
	*/
	dds.header.ddspf.dwRGBBitCount = 0;
	dds.header.ddspf.dwRBitMask = 0;
	dds.header.ddspf.dwGBitMask = 0;
	dds.header.ddspf.dwBBitMask = 0;
	dds.header.ddspf.dwABitMask = 0;

	dds.header.dwCaps = DDSCAPS_TEXTURE;
	if (g_system.num_mipmap_levels > 1)
		dds.header.dwCaps |= DDSCAPS_MIPMAP | DDSCAPS_COMPLEX;
	dds.header.dwCaps2 = 0;
	dds.header.dwCaps3 = 0;
	dds.header.dwCaps4 = 0;
	dds.header.dwReserved2 = 0;

	dds.header_dxt10.dxgiFormat = DDS_GLFormatToDXFormat(format);
	dds.header_dxt10.resourceDimension = D3D10_RESOURCE_DIMENSION_TEXTURE2D;
	dds.header_dxt10.miscFlag = 0;
	dds.header_dxt10.arraySize = 1;
	//dds.header_dxt10.miscFlags2 = DDS_ALPHA_MODE_STRAIGHT;
	dds.header_dxt10.miscFlags2 = 0;

	fopen_s(&f, output_name, "wb");

	if (!f)
	{
		ALWAYS_PRINT("Could not open file \"%s\" for writing\n", output_name);
		return -1;
	}

	fwrite(&dds.magic, sizeof(DWORD), 1, f);

	fwrite(&dds.header.dwSize, sizeof(DWORD), 1, f);
	fwrite(&dds.header.dwFlags, sizeof(DWORD), 1, f);
	fwrite(&dds.header.dwHeight, sizeof(DWORD), 1, f);
	fwrite(&dds.header.dwWidth, sizeof(DWORD), 1, f);
	fwrite(&dds.header.dwPitchOrLinearSize, sizeof(DWORD), 1, f);
	fwrite(&dds.header.dwDepth, sizeof(DWORD), 1, f);
	fwrite(&dds.header.dwMipMapCount, sizeof(DWORD), 1, f);
	fwrite(dds.header.dwReserved1, sizeof(DWORD), 11, f);

	fwrite(&dds.header.ddspf.dwSize, sizeof(DWORD), 1, f);
	fwrite(&dds.header.ddspf.dwFlags, sizeof(DWORD), 1, f);
	fwrite(&dds.header.ddspf.dwFourCC, sizeof(DWORD), 1, f);
	fwrite(&dds.header.ddspf.dwRGBBitCount, sizeof(DWORD), 1, f);
	fwrite(&dds.header.ddspf.dwRBitMask, sizeof(DWORD), 1, f);
	fwrite(&dds.header.ddspf.dwGBitMask, sizeof(DWORD), 1, f);
	fwrite(&dds.header.ddspf.dwBBitMask, sizeof(DWORD), 1, f);
	fwrite(&dds.header.ddspf.dwABitMask, sizeof(DWORD), 1, f);

	fwrite(&dds.header.dwCaps, sizeof(DWORD), 1, f);
	fwrite(&dds.header.dwCaps2, sizeof(DWORD), 1, f);
	fwrite(&dds.header.dwCaps3, sizeof(DWORD), 1, f);
	fwrite(&dds.header.dwCaps4, sizeof(DWORD), 1, f);
	fwrite(&dds.header.dwReserved2, sizeof(DWORD), 1, f);

	if (!DDS_GLFormatIsDX9(format))
	{
		fwrite(&dds.header_dxt10.dxgiFormat, sizeof(DXGI_FORMAT), 1, f);
		fwrite(&dds.header_dxt10.resourceDimension, sizeof(D3D10_RESOURCE_DIMENSION), 1, f);
		fwrite(&dds.header_dxt10.miscFlag, sizeof(UINT), 1, f);
		fwrite(&dds.header_dxt10.arraySize, sizeof(UINT), 1, f);
		fwrite(&dds.header_dxt10.miscFlags2, sizeof(UINT), 1, f);
	}
	for (i = 0; i < g_system.num_mipmap_levels; i++)
	{
		fwrite(g_system.image[i].encoded, 1, DDS_BlockSize(format) * ((g_system.image[i].width + 3) >> 2) * ((g_system.image[i].height + 3) >> 2), f);
	}

	fclose(f);

	return 0;
}
#if 0
double DDS_RGBA8ToLuminance(uint8_t *rgba)
{
	return 0.2126 * rgba[0] + 0.7152 * rgba[1] + 0.0722 * rgba[2];
}

// TODO: remember and test the reference image with itself!
void DDS_SSIM(uint8_t *rgbau8_ref, uint8_t *rgbau8, int width, int height, int xorg, int yorg, int window_size, float *lx, float *cx, float *sx)
{
	double k1 = 0.01;
	double k2 = 0.03;
	double L = 255.0;
	double c1 = (k1*L)*(k1*L);
	double c2 = (k2*L)*(k2*L);
	double c3 = c2 / 2.0;
	double window_luminance[2];
	double window_mean[2];
	double variance[2];
	double covariance = 0.0;
	double window_weights[128];
	int i;
	int x;
	int y;
	int xmins = Math_Clampi32(xorg - window_size, 0, width - 1);
	int xmaxs = Math_Clampi32(xorg + window_size, 0, width - 1);
	int ymins = Math_Clampi32(yorg - window_size, 0, height - 1);
	int ymaxs = Math_Clampi32(yorg + window_size, 0, height - 1);
	double total_pixels = (xmaxs - xmins + 1) * (ymaxs - ymins + 1);
	uint8_t *rgba[2] = {rgbau8_ref, rgbau8};
	double std = 1.5;
	double weights_total = 0.0f;
	int x_offset = xmins - (xorg - window_size);
	int y_offset = ymins - (yorg - window_size);
	for (i = 0; i < 2*window_size + 1; i++)
	{
		window_weights[i] = (1.0/(std*sqrt(2*M_PI)))*exp(-(1.0/2.0)*pow((i - window_size)/std, 2.0));
	}
	for (y = ymins; y <= ymaxs; y++)
		for (x = xmins; x <= xmaxs; x++)
			weights_total += window_weights[x - xmins + x_offset] * window_weights[y - ymins + y_offset];
	for (i = 0; i < 2*window_size + 1; i++)
		window_weights[i] /= weights_total;

	for (i = 0; i < 2; i++)
	{
		window_luminance[i] = 0.0;
		window_mean[i] = 0.0;
		variance[i] = 0.0;

		for (y = ymins; y <= ymaxs; y++)
			for (x = xmins; x <= xmaxs; x++)
				window_mean[i] += DDS_RGBA8ToLuminance(&rgba[i][(y * width + x) * 4]) * window_weights[x - xmins + x_offset] * window_weights[y - ymins + y_offset];

		window_mean[i] /= total_pixels;

		for (y = ymins; y <= ymaxs; y++)
			for (x = xmins; x <= xmaxs; x++)
				variance[i] += pow(DDS_RGBA8ToLuminance(&rgba[i][(y * width + x) * 4]) - window_mean[i], 2.0) * window_weights[x - xmins + x_offset] * window_weights[y - ymins + y_offset];

		//variance[i] /= total_pixels - 1;
		variance[i] = sqrt(variance[i]);
	}

	for (y = ymins; y <= ymaxs; y++)
		for (x = xmins; x <= xmaxs; x++)
			covariance += (DDS_RGBA8ToLuminance(&rgba[0][(y * width + x) * 4]) - window_mean[0]) * (DDS_RGBA8ToLuminance(&rgba[1][(y * width + x) * 4]) - window_mean[1]) * window_weights[x - xmins + x_offset] * window_weights[y - ymins + y_offset];

	//covariance /= total_pixels - 1;

	//printf("mean: %5i %5i, %f %f\n", xorg, yorg, window_mean[0], window_mean[1]);

	*lx = (2.0 * window_mean[0] * window_mean[1] + c1) / (pow(window_mean[0], 2.0) + pow(window_mean[1], 2.0) + c1);
	*cx = (2.0 * variance[0] * variance[1] + c2) / (pow(variance[0], 2.0) + pow(variance[1], 2.0) + c2);
	*sx = (covariance + c3) / (variance[0] * variance[1] + c3);
}

int DDS_SSIMCompare(void *arg0, void *arg1)
{
	if (*(float*)arg0 < *(float*)arg1)
		return -1;
	else if (*(float*)arg0 > *(float*)arg1)
		return 1;
	else
		return 0;
}

void DDS_Test()
{
	ILuint image;
	ILboolean result;
	ILuint uint_result;
	ILuint width;
	ILuint height;
	unsigned char *rgba_u8[2][6];
	unsigned char *rgba_u8_ref;
	int i;
	wchar_t *path[] = 
	{
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\BC1RGB_DX9.dds",
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\BC1RGBA.dds",
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\BC2RGBA.dds",
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\BC3RGBA.dds",
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\BC4RED.dds",
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\BC5RG.dds",
	};
	wchar_t *ref_path[] = 
	{
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\crunch.dds",
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\BC1RGBA_PVRTT.dds",
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\BC2RGBA_PVRTT.dds",
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\BC3RGBA_PVRTT.dds",
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\BC4RED_PVRTT.dds",
		L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\BC5RG_PVRTT.dds",
	};
	/*
	int cround5[256][2] = {-1};
	int cround6[256][2] = {-1};
	int cround5_alpha[256][2] = {-1};
	int cround6_alpha[256][2] = {-1};
	for (i = 0; i < 256; i++)
	{
		cround5[i][0] = -1;
		cround5[i][1] = -1;
		cround6[i][0] = -1;
		cround6[i][1] = -1;
		cround5_alpha[i][0] = -1;
		cround5_alpha[i][1] = -1;
		cround6_alpha[i][0] = -1;
		cround6_alpha[i][1] = -1;
	}
	for(i = 0; i < 32; i++)
	{
		for(int j = i; j < 32; j++)
		{
			float c1 = i*8 + (j - i)*8/3.0f;
			float c2 = i*8 + 2.0f*(j - i)*8/3.0f;
			int c1i = (int)Math_Clampf32(floorf(c1 + 0.5f), 0.0f, 255.0f);
			int c2i = (int)Math_Clampf32(floorf(c2 + 0.5f), 0.0f, 255.0f);

			cround5[c1i][0] = i;
			cround5[c1i][1] = j;
			cround5[c2i][0] = i;
			cround5[c2i][1] = j;

			c1 = i*8 + (j - i)*8/2.0f;

			c1i = (int)Math_Clampf32(floorf(c1 + 0.5f), 0.0f, 255.0f);

			cround5_alpha[c1i][0] = i;
			cround5_alpha[c1i][1] = j;
		}
	}
	for(i = 0; i < 64; i++)
	{
		for(int j = i; j < 64; j++)
		{
			float c1 = i*4 + (j - i)*4/3.0f;
			float c2 = i*4 + 2.0f*(j - i)*4/3.0f;
			int c1i = (int)Math_Clampf32(floorf(c1 + 0.5f), 0.0f, 255.0f);
			int c2i = (int)Math_Clampf32(floorf(c2 + 0.5f), 0.0f, 255.0f);

			cround6[c1i][0] = i;
			cround6[c1i][1] = j;
			cround6[c2i][0] = i;
			cround6[c2i][1] = j;

			c1 = i*4 + (j - i)*4/2.0f;

			c1i = (int)Math_Clampf32(floorf(c1 + 0.5f), 0.0f, 255.0f);

			cround6_alpha[c1i][0] = i;
			cround6_alpha[c1i][1] = j;
		}
	}

	printf("g_dds_round5[256] = {\n");
	for (i = 0; i < 256; i++)
		printf("{%i, %i},\n", cround5[i][0], cround5[i][1]);
	printf("};\n");
	printf("g_dds_round5_alpha[256] = {\n");
	for (i = 0; i < 256; i++)
		printf("{%i, %i},\n", cround5_alpha[i][0], cround5_alpha[i][1]);
	printf("};\n");
	printf("g_dds_round6[256] = {\n");
	for (i = 0; i < 256; i++)
		printf("{%i, %i},\n", cround6[i][0], cround6[i][1]);
	printf("};\n");
	printf("g_dds_round6_alpha[256] = {\n");
	for (i = 0; i < 256; i++)
		printf("{%i, %i},\n", cround6_alpha[i][0], cround6_alpha[i][1]);
	printf("};\n");

	exit(0);
	*/
	if(0)
	{
		int i;
		vec3u8_t path_quantised[192];
		vec3u8_t start_quantised = Vec3u8_Vec(0, 0, 0);
		vec3u8_t end_quantised = Vec3u8_Vec(3, 3, 3);
		int count = DDS_BresenhamPath16BitVisitAll(path_quantised, start_quantised, end_quantised);
		for (i = 0; i < count; i++)
			printf("%2i: %3u %3u %3u\n", i, path_quantised[i].v[0], path_quantised[i].v[1], path_quantised[i].v[2]);
		exit(0);

		int max_count[64] = {0};
		spinlock_t spinlock = SPINLOCK_INIT;
		for (i = 0; i < 32; i++)
		{
			printf("%i\n", i);
			int j;
#pragma omp parallel for private(j)
			for (j = 0; j < 32; j++)
			{
				for (int k = 0; k < 32; k++)
					for (int i2 = 0; i2 < 32; i2++)
						for (int j2 = 0; j2 < 64; j2++)
							for (int k2 = 0; k2 < 32; k2++)
							{
								vec3u8_t path_quantised[192];
								vec3u8_t start_quantised = Vec3u8_Vec(i, j, k);
								vec3u8_t end_quantised = Vec3u8_Vec(i2, j2, k2);
								int count = DDS_BresenhamPath16BitVisitAll(path_quantised, start_quantised, end_quantised);
								//SpinLock_Lock(&spinlock);
								if (count > max_count[omp_get_thread_num()])
								{
									max_count[omp_get_thread_num()] = count;
									printf("max[%2i]: %5i (%2i %2i %2i -> %2i %2i %2i)\n", omp_get_thread_num(), max_count[omp_get_thread_num()], start_quantised.v[0], start_quantised.v[1], start_quantised.v[2], end_quantised.v[0], end_quantised.v[1], end_quantised.v[2]);
								}
								//SpinLock_Unlock(&spinlock);
							}
			}
		}
		for (i = 1; i < 24; i++)
			if (max_count[i] > max_count[0])
				max_count[0] = max_count[i];
		printf("max count: %i\n", max_count[0]);
		exit(0);
	}













	//return;
	static int inty = 0;
	inty++;
	if (inty < 2)
	return;

	ilInit();
	iluInit();
	ilutInit();
	ilutRenderer(ILUT_WIN32);

	ilEnable(IL_ORIGIN_SET);
	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);

	ilGenImages(1, &image);
	ilBindImage(image);

	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\sprite.bmp");
	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\512x512noalphablurred.bmp");
	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\512x512noalpha.bmp");
	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\1024x1024withgradient.bmp");
	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\128x128withgradient.bmp");
	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\512x512noalphablurred.bmp");
	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\512x512withgradient.bmp");
	
	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\212x116blurredgradient.bmp");
	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\256x144blurredgradient.bmp");
	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\256x144gradient.bmp");
	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\256x144halfblurredgradient.bmp");
	result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\256x144halfblurredgradient_constantgreen.bmp");
	//result = ilLoadImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\1024x1024noise.bmp");
	printf("result: %i\n", result);
	width = ilGetInteger(IL_IMAGE_WIDTH);
	height = ilGetInteger(IL_IMAGE_HEIGHT);
	rgba_u8_ref = Mem_Malloc(width * height * 4);
	uint_result = ilCopyPixels(0, 0, 0, width, height, 1, IL_RGBA, IL_UNSIGNED_BYTE, rgba_u8_ref);


	for (i = 0; i < 6; i++)
	{
		int result0;
		int result1;
		uint8_t *block0;
		uint8_t *block1;
		ilGenImages(1, &image);
		ilBindImage(image);

		block0 = Mem_Malloc(width * height * 4);
		block1 = Mem_Malloc(width * height * 4);

		result0 = ilLoadImage(path[i]);
		rgba_u8[0][i] = Mem_Malloc(width * height * 4);
		printf("result0: %i\n", result0);
		printf("width / height: %i x %i\n", width, height);
		result0 = 0;
		if (result0)
		{
			uint_result = ilCopyPixels(0, 0, 0, width, height, 1, IL_RGBA, IL_UNSIGNED_BYTE, rgba_u8[0][i]);
		}
		else
		{
			FILE *f;
			int x; 
			int y;
			uint8_t *data = Mem_Malloc((width + 3) * (height + 3));
			_wfopen_s(&f, path[i], L"rb");
			//fseek(f, 148, SEEK_SET);
			fseek(f, 128, SEEK_SET);	// DX9
			if (i == 0 || i == 1 || i == 4)
				fread(data, 1, (width * height) >> 1, f);
			else
				fread(data, 1, width * height, f);
			
			for (int off = 0, y = 0; y < ((height + 3) >> 2); y++)
				for (x = 0; x < ((width + 3) >> 2); x++, off++)
				{
					int i2, j, k;
					uint8_t local_block[16];
					float pixel_rgbaf32[64];
					const int local_width = (int)(width - x * 4 < 4 ? width - x * 4 : 4);
					const int local_height = (int)(height - y * 4 < 4 ? height - y * 4 : 4);

					if (i == 0)
						DDS_DecodeBC1Block(&data[(y*((width + 3) >> 2) + x) * 8], pixel_rgbaf32, 0, 0, 0, x, y);
					else if (i == 1)
						DDS_DecodeBC1Block(&data[(y*((width + 3) >> 2) + x) * 8], pixel_rgbaf32, 0, 0, 0, x, y);
					else if (i == 2)
						DDS_DecodeBC2Block(&data[(y*((width + 3) >> 2) + x) * 16], pixel_rgbaf32, 0, 0, 0, x, y);
					else if (i == 3)
						DDS_DecodeBC3Block(&data[(y*((width + 3) >> 2) + x) * 16], pixel_rgbaf32, 0, 0, 0, x, y);
					else if (i == 4)
						DDS_DecodeBC4Block(&data[(y*((width + 3) >> 2) + x) * 8], pixel_rgbaf32, 0, 0, 0, x, y);
					else if (i == 5)
						DDS_DecodeBC5Block(&data[(y*((width + 3) >> 2) + x) * 16], pixel_rgbaf32, 0, 0, 0, x, y);

					for (i2 = 0; i2 < local_height; i2++)
						for (j = 0; j < local_width; j++)
							for (k = 0; k < 4; k++)
								rgba_u8[0][i][((y*4 + i2)*width + (x*4 + j))*4 + k] = pixel_rgbaf32[(i2*4 + j)*4 + k];
					for (k = 0; k < 64; k++)
						block0[off*64 + k] = pixel_rgbaf32[k];
				}
			result0 = 1;
		}
		if (i == 0)
		{
			uint8_t *data = Mem_Malloc(width * height * 4);
			uint8_t *contrast_data = Mem_Malloc(width * height * 4);
			int j;
			FILE *f;
			ilEnable(IL_FILE_OVERWRITE);
			printf("width/height2: %i x %i\n", width, height);
			ILuint t;
			ilGenImages(1, &t);
			ilBindImage(t);
			for (j = 0; j < height; j++)
				memcpy(&data[j * width * 4], &rgba_u8[0][i][(height - j - 1) * width * 4], width * 4);
			ilTexImage(width, height, 1, 4, IL_RGBA, IL_UNSIGNED_BYTE, data);
			ilSaveImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\rawdecoded.tga");

			for (j = 0; j < width * height * 4; j+=4)
			{
				float mins = 25;
				float maxs = 70;
				contrast_data[j + 0] = Math_Clampi32(0.5f + 255.0f * ((float)data[j + 0] - mins) / (maxs - mins), 0, 255);
				contrast_data[j + 1] = Math_Clampi32(0.5f + 255.0f * ((float)data[j + 1] - mins) / (maxs - mins), 0, 255);
				contrast_data[j + 2] = Math_Clampi32(0.5f + 255.0f * ((float)data[j + 2] - mins) / (maxs - mins), 0, 255);
				contrast_data[j + 3] = data[j + 3];
			}
			ilTexImage(width, height, 1, 4, IL_RGBA, IL_UNSIGNED_BYTE, contrast_data);
			ilSaveImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\rawdecoded_contrast.tga");

			for (j = 0; j < height; j++)
				memcpy(&data[j * width * 4], &rgba_u8_ref[(height - j - 1) * width * 4], width * 4);
			ilTexImage(width, height, 1, 4, IL_RGBA, IL_UNSIGNED_BYTE, data);
			ilSaveImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\rawdecoded_ref.tga");

			for (j = 0; j < width * height * 4; j+=4)
			{
				float mins = 25;
				float maxs = 70;
				contrast_data[j + 0] = Math_Clampi32(0.5f + 255.0f * ((float)data[j + 0] - mins) / (maxs - mins), 0, 255);
				contrast_data[j + 1] = Math_Clampi32(0.5f + 255.0f * ((float)data[j + 1] - mins) / (maxs - mins), 0, 255);
				contrast_data[j + 2] = Math_Clampi32(0.5f + 255.0f * ((float)data[j + 2] - mins) / (maxs - mins), 0, 255);
				contrast_data[j + 3] = data[j + 3];
			}
			ilTexImage(width, height, 1, 4, IL_RGBA, IL_UNSIGNED_BYTE, contrast_data);
			ilSaveImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\rawdecoded_contrast_ref.tga");

			Mem_Free(data);
		}
		if (i == 0)
		{
			char *data_ref = Mem_Malloc(width * height * 4);
			char *data = Mem_Malloc(width * height * 4);
			float *data_f32 = Mem_Malloc(width * height * 4 * sizeof(float));
			float *data_f32_lx = Mem_Malloc(width * height * sizeof(float));
			float *data_f32_cx = Mem_Malloc(width * height * sizeof(float));
			float *data_f32_sx = Mem_Malloc(width * height * sizeof(float));
			float *data_f32_ssim = Mem_Malloc(width * height * sizeof(float));
			int j;
			int x;
			int y;
			float mins[4];
			float maxs[4];
			FILE *f;
			ilEnable(IL_FILE_OVERWRITE);
			printf("width/height2: %i x %i\n", width, height);
			ILuint t;
			ilGenImages(1, &t);
			ilBindImage(t);
			
			for (j = 0; j < height; j++)
				memcpy(&data[j * width * 4], &rgba_u8[0][i][(height - j - 1) * width * 4], width * 4);
			for (j = 0; j < height; j++)
				memcpy(&data_ref[j * width * 4], &rgba_u8_ref[(height - j - 1) * width * 4], width * 4);

#pragma omp parallel for private(y) private(x)
			for (y = 0; y < height; y++)
				for (x = 0; x < width; x++)
				{
					DDS_SSIM(data_ref, data, width, height, x, y, 5, &data_f32[(y * width + x)*4 + 0], &data_f32[(y * width + x)*4 + 1], &data_f32[(y * width + x)*4 + 2]);
					data_f32[(y * width + x)*4 + 3] = data_f32[(y * width + x)*4 + 0] * data_f32[(y * width + x)*4 + 1] * data_f32[(y * width + x)*4 + 2];
					//printf("%5i %5i: %f %f %f = %f\n", x, y, data_f32[(y * width + x)*4 + 0], data_f32[(y * width + x)*4 + 1], data_f32[(y * width + x)*4 + 2], data_f32[(y * width + x)*4 + 3]);
				}

			for (x = 0; x < width * height; x++)
			{
				data_f32_lx[x] = data_f32[x*4 + 0];
				data_f32_cx[x] = data_f32[x*4 + 1];
				data_f32_sx[x] = data_f32[x*4 + 2];
				data_f32_ssim[x] = data_f32_lx[x] * data_f32_cx[x] * data_f32_sx[x];
			}

			qsort(data_f32_lx, width * height, sizeof(float), DDS_SSIMCompare);
			qsort(data_f32_cx, width * height, sizeof(float), DDS_SSIMCompare);
			qsort(data_f32_sx, width * height, sizeof(float), DDS_SSIMCompare);
			qsort(data_f32_ssim, width * height, sizeof(float), DDS_SSIMCompare);

			mins[0] = data_f32_lx[(width * height) >> 4];
			mins[1] = data_f32_cx[(width * height) >> 4];
			mins[2] = data_f32_sx[(width * height) >> 4];
			mins[3] = data_f32_ssim[(width * height) >> 4];
			maxs[0] = data_f32_lx[(width * height) - 1];
			maxs[1] = data_f32_cx[(width * height) - 1];
			maxs[2] = data_f32_sx[(width * height) - 1];
			maxs[3] = data_f32_ssim[(width * height) - 1];

			mins[0] = 0.999997;
			mins[1] = 0.999974;
			mins[2] = 0.999598 + 0.0002;
			mins[3] = 0.999572;

			maxs[0] = 1.0;
			maxs[1] = 1.0;
			maxs[2] = 1.0;
			maxs[3] = 1.0;

			printf("LX   %f -> %f\n", mins[0], maxs[0]);
			printf("CX   %f -> %f\n", mins[1], maxs[1]);
			printf("SX   %f -> %f\n", mins[2], maxs[2]);
			printf("SSIM %f -> %f\n", mins[3], maxs[3]);

			/*
			for (j = 0; j < 4; j++)
			{
				mins[j] = 99999999999.0f;
				maxs[j] = -99999999999.0f;
				for (y = 10; y < height - 10; y++)
					for (x = 10; x < width - 10; x++)
					{
						mins[j] = Math_Minf32(mins[j], data_f32[(y*width + x)*4 + j]);
						maxs[j] = Math_Maxf32(maxs[j], data_f32[(y*width + x)*4 + j]);
					}
			}
			*/
			/*for (j = 0; j < 4; j++)
			{
				mins[j] = 0.97;
				maxs[j] = 1.0;
			}*/
			for (y = 0; y < height; y++)
				for (x = 0; x < width; x++)
					for (j = 0; j < 4; j++)
					{
						data[(y * width + x)*4 + j] = Math_Clampf32(floorf(255.0 * ((data_f32[(y * width + x)*4 + j] - mins[j]) / (maxs[j] - mins[j]))), 0.0f, 255.0f);
						if (j == 3)
							data[(y * width + x)*4 + j] = 255;
					}

			printf("mins: %5f %5f %5f %5f\n", mins[0], mins[1], mins[2], mins[3]);
			printf("maxs: %5f %5f %5f %5f\n", maxs[0], maxs[1], maxs[2], maxs[3]);
			ilTexImage(width, height, 1, 4, IL_RGBA, IL_UNSIGNED_BYTE, data);
			ilSaveImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\rawdecoded_ssim_channels.tga");

			for (y = 0; y < height; y++)
				for (x = 0; x < width; x++)
				{
					int value = (int)Math_Clampf32(1023.0f - floorf(0.5f + 1023.0f * ((data_f32[(y * width + x)*4 + 3] - mins[3]) / (maxs[3] - mins[3]))), 0.0f, 1023.0f);
					data[(y * width + x)*4 + 0] = g_dds_inferno_colourmap[value][0];
					data[(y * width + x)*4 + 1] = g_dds_inferno_colourmap[value][1];
					data[(y * width + x)*4 + 2] = g_dds_inferno_colourmap[value][2];
					data[(y * width + x)*4 + 3] = 255;
				}

			printf("mins: %5f %5f %5f %5f\n", mins[0], mins[1], mins[2], mins[3]);
			printf("maxs: %5f %5f %5f %5f\n", maxs[0], maxs[1], maxs[2], maxs[3]);
			ilTexImage(width, height, 1, 4, IL_RGBA, IL_UNSIGNED_BYTE, data);
			ilSaveImage(L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\rawdecoded_ssim.tga");

			Mem_Free(data);
		}

		ilGenImages(1, &image);
		ilBindImage(image);
		rgba_u8[1][i] = Mem_Malloc(width * height * 4);
		result1 = ilLoadImage(ref_path[i]);
		printf("result1: %i\n", result1);
		result1 = 0;
		if (result1)
		{
			uint_result = ilCopyPixels(0, 0, 0, width, height, 1, IL_RGBA, IL_UNSIGNED_BYTE, rgba_u8[1][i]);
		}
		else
		{
			FILE *f;
			int x; 
			int y;
			uint8_t *data = Mem_Malloc((width + 3) * (height + 3));
			_wfopen_s(&f, ref_path[i], L"rb");
			//fseek(f, 148, SEEK_SET);
			fseek(f, 128, SEEK_SET); // DX9
			if (i == 0 || i == 1 || i == 4)
				fread(data, 1, (width * height) >> 1, f);
			else
				fread(data, 1, width * height, f);

			for (int off = 0, y = 0; y < ((height + 3) >> 2); y++)
				for (x = 0; x < ((width + 3) >> 2); x++, off++)
				{
					int i2, j, k;
					uint8_t local_block[16];
					float pixel_rgbaf32[64];
					const int local_width = (int)(width - x * 4 < 4 ? width - x * 4 : 4);
					const int local_height = (int)(height - y * 4 < 4 ? height - y * 4 : 4);

					if (i == 0)
						DDS_DecodeBC1Block(&data[(y*((width + 3) >> 2) + x) * 8], pixel_rgbaf32, 0, 0, 0, x, y);
					else if (i == 1)
						DDS_DecodeBC1Block(&data[(y*((width + 3) >> 2) + x) * 8], pixel_rgbaf32, 0, 0, 0, x, y);
					else if (i == 2)
						DDS_DecodeBC2Block(&data[(y*((width + 3) >> 2) + x) * 16], pixel_rgbaf32, 0, 0, 0, x, y);
					else if (i == 3)
						DDS_DecodeBC3Block(&data[(y*((width + 3) >> 2) + x) * 16], pixel_rgbaf32, 0, 0, 0, x, y);
					else if (i == 4)
						DDS_DecodeBC4Block(&data[(y*((width + 3) >> 2) + x) * 8], pixel_rgbaf32, 0, 0, 0, x, y);
					else if (i == 5)
						DDS_DecodeBC5Block(&data[(y*((width + 3) >> 2) + x) * 16], pixel_rgbaf32, 0, 0, 0, x, y);

					for (i2 = 0; i2 < local_height; i2++)
						for (j = 0; j < local_width; j++)
							for (k = 0; k < 4; k++)
								rgba_u8[1][i][((y*4 + i2)*width + (x*4 + j))*4 + k] = pixel_rgbaf32[(i2*4 + j)*4 + k];
					for (k = 0; k < 64; k++)
						block1[off*64 + k] = pixel_rgbaf32[k];
				}
			result1 = 1;
		}
		if (i == 0)
		{
			FILE *f;
			int j;
			printf("width/height2: %i x %i\n", width, height);
			_wfopen_s(&f, L"E:\\Craig\\Programming\\New Stuff\\ImageCompressor\\x64\\Release\\rawcrunch.raw", L"wb");
			for (j = 0; j < width*height*4; j+=4)
				fwrite(&rgba_u8[1][i][j], 1, 3, f);
			fclose(f);
		}

		if (result0 && result1)
		{
			int j;
			float *lerr0 = Mem_Malloc(width * height * sizeof(float));
			float *lerr1 = Mem_Malloc(width * height * sizeof(float));
			float *blockerr0 = Mem_Malloc(width * height * sizeof(float));
			float *blockerr1 = Mem_Malloc(width * height * sizeof(float));
			double error0 = 0.0;
			double error1 = 0.0;
			double alpha_error0 = 0.0;
			double alpha_error1 = 0.0;
			int count0 = 0;
			int count1 = 0;
			int alpha_count0 = 0;
			int alpha_count1 = 0;
			printf("%ls vs %ls\n", path[i], ref_path[i]);
			for (j = 0; j < width * height; j++)
			{
				lerr0[j] = 0.0f;
				lerr1[j] = 0.0f;
				blockerr0[j] = 0.0f;
				blockerr1[j] = 0.0f;
			}
			for (j = 0; j < width * height * 4; j+=4)
			{
				if ((i == 1 && rgba_u8[0][i][j + 3]) || (i != 1))
				{
					if (i < 4)
					{
						error0 += (rgba_u8[0][i][j + 0] - rgba_u8_ref[j + 0]) * (rgba_u8[0][i][j + 0] - rgba_u8_ref[j + 0]);
						error0 += (rgba_u8[0][i][j + 1] - rgba_u8_ref[j + 1]) * (rgba_u8[0][i][j + 1] - rgba_u8_ref[j + 1]);
						error0 += (rgba_u8[0][i][j + 2] - rgba_u8_ref[j + 2]) * (rgba_u8[0][i][j + 2] - rgba_u8_ref[j + 2]);
						lerr0[j/4] = (rgba_u8[0][i][j + 0] - rgba_u8_ref[j + 0]) * (rgba_u8[0][i][j + 0] - rgba_u8_ref[j + 0]) +
							(rgba_u8[0][i][j + 1] - rgba_u8_ref[j + 1]) * (rgba_u8[0][i][j + 1] - rgba_u8_ref[j + 1]) +
							(rgba_u8[0][i][j + 2] - rgba_u8_ref[j + 2]) * (rgba_u8[0][i][j + 2] - rgba_u8_ref[j + 2]);

					}
					else if (i == 4)
					{
						error0 += (rgba_u8[0][i][j + 0] - rgba_u8_ref[j + 0]) * (rgba_u8[0][i][j + 0] - rgba_u8_ref[j + 0]);
					}
					else if (i == 5)
					{
						error0 += (rgba_u8[0][i][j + 0] - rgba_u8_ref[j + 0]) * (rgba_u8[0][i][j + 0] - rgba_u8_ref[j + 0]);
						error0 += (rgba_u8[0][i][j + 1] - rgba_u8_ref[j + 1]) * (rgba_u8[0][i][j + 1] - rgba_u8_ref[j + 1]);
					}
					count0++;
				}
				if (i == 2 || i == 3)
				{
					alpha_error0 += (rgba_u8[0][i][j + 3] - rgba_u8_ref[j + 3]) * (rgba_u8[0][i][j + 3] - rgba_u8_ref[j + 3]);
					alpha_error1 += (rgba_u8[1][i][j + 3] - rgba_u8_ref[j + 3]) * (rgba_u8[1][i][j + 3] - rgba_u8_ref[j + 3]);

					alpha_count0++;
					alpha_count1++;
				}
				if ((i == 1 && rgba_u8[1][i][j + 3]) || (i != 1))
				{
					if (i < 4)
					{
						error1 += (rgba_u8[1][i][j + 0] - rgba_u8_ref[j + 0]) * (rgba_u8[1][i][j + 0] - rgba_u8_ref[j + 0]);
						error1 += (rgba_u8[1][i][j + 1] - rgba_u8_ref[j + 1]) * (rgba_u8[1][i][j + 1] - rgba_u8_ref[j + 1]);
						error1 += (rgba_u8[1][i][j + 2] - rgba_u8_ref[j + 2]) * (rgba_u8[1][i][j + 2] - rgba_u8_ref[j + 2]);
						lerr1[j/4] = (rgba_u8[1][i][j + 0] - rgba_u8_ref[j + 0]) * (rgba_u8[1][i][j + 0] - rgba_u8_ref[j + 0]) +
							(rgba_u8[1][i][j + 1] - rgba_u8_ref[j + 1]) * (rgba_u8[1][i][j + 1] - rgba_u8_ref[j + 1]) +
							(rgba_u8[1][i][j + 2] - rgba_u8_ref[j + 2]) * (rgba_u8[1][i][j + 2] - rgba_u8_ref[j + 2]);
					}
					else if (i == 4)
					{
						error1 += (rgba_u8[1][i][j + 0] - rgba_u8_ref[j + 0]) * (rgba_u8[1][i][j + 0] - rgba_u8_ref[j + 0]);
					}
					else if (i == 5)
					{
						error1 += (rgba_u8[1][i][j + 0] - rgba_u8_ref[j + 0]) * (rgba_u8[1][i][j + 0] - rgba_u8_ref[j + 0]);
						error1 += (rgba_u8[1][i][j + 1] - rgba_u8_ref[j + 1]) * (rgba_u8[1][i][j + 1] - rgba_u8_ref[j + 1]);
					}
					count1++;
				}
			}
			count0 = count0 ? count0 : 1;
			count1 = count1 ? count1 : 1;
			alpha_count0 = alpha_count0 ? alpha_count0 : 1;
			alpha_count1 = alpha_count1 ? alpha_count1 : 1;

			float tlerr0 = 0.0f;
			float tlerr1 = 0.0f;
			int total_blocks = ((width + 3) >> 2) * ((height + 3) >> 2);
			int bad_blocks = 0;

			for (int y = 0, block_y = 0; y < height; y+=4, block_y++)
				for (int x = 0, block_x = 0; x < width; x+=4, block_x++)
				{
					for (int local_y = 0; local_y < 4; local_y++)
					{
						int block_offset = (y*width + x)*4;
						int local_offset[4];
						local_offset[0] = (local_y*width + 0)*4;
						local_offset[1] = (local_y*width + 1)*4;
						local_offset[2] = (local_y*width + 2)*4;
						local_offset[3] = (local_y*width + 3)*4;
						if (DDS_DEBUG_BLOCK)
							printf("ref %5i %5i: %3u %3u %3u, %3u %3u %3u, %3u %3u %3u, %3u %3u %3u\n", block_x, block_y
								, rgba_u8_ref[(block_offset + local_offset[0]) + 0], rgba_u8_ref[(block_offset + local_offset[0]) + 1], rgba_u8_ref[(block_offset + local_offset[0]) + 2]
								, rgba_u8_ref[(block_offset + local_offset[1]) + 0], rgba_u8_ref[(block_offset + local_offset[1]) + 1], rgba_u8_ref[(block_offset + local_offset[1]) + 2]
								, rgba_u8_ref[(block_offset + local_offset[2]) + 0], rgba_u8_ref[(block_offset + local_offset[2]) + 1], rgba_u8_ref[(block_offset + local_offset[2]) + 2]
								, rgba_u8_ref[(block_offset + local_offset[3]) + 0], rgba_u8_ref[(block_offset + local_offset[3]) + 1], rgba_u8_ref[(block_offset + local_offset[3]) + 2]);
					}

					for (int local_y = 0; local_y < 4; local_y++)
						for (int local_x = 0; local_x < 4; local_x++)
						{
							int block_offset = (y*width + x)*4;
							int local_offset = (local_y*width + local_x)*4;

							blockerr0[(y/4)*(width/4) + x/4] += ((int)rgba_u8[0][i][(block_offset + local_offset) + 0] - (int)rgba_u8_ref[(block_offset + local_offset) + 0])*((int)rgba_u8[0][i][(block_offset + local_offset) + 0] - (int)rgba_u8_ref[(block_offset + local_offset) + 0]);
							blockerr0[(y/4)*(width/4) + x/4] += ((int)rgba_u8[0][i][(block_offset + local_offset) + 1] - (int)rgba_u8_ref[(block_offset + local_offset) + 1])*((int)rgba_u8[0][i][(block_offset + local_offset) + 1] - (int)rgba_u8_ref[(block_offset + local_offset) + 1]);
							blockerr0[(y/4)*(width/4) + x/4] += ((int)rgba_u8[0][i][(block_offset + local_offset) + 2] - (int)rgba_u8_ref[(block_offset + local_offset) + 2])*((int)rgba_u8[0][i][(block_offset + local_offset) + 2] - (int)rgba_u8_ref[(block_offset + local_offset) + 2]);

							blockerr1[(y/4)*(width/4) + x/4] += ((int)rgba_u8[1][i][(block_offset + local_offset) + 0] - (int)rgba_u8_ref[(block_offset + local_offset) + 0])*((int)rgba_u8[1][i][(block_offset + local_offset) + 0] - (int)rgba_u8_ref[(block_offset + local_offset) + 0]);
							blockerr1[(y/4)*(width/4) + x/4] += ((int)rgba_u8[1][i][(block_offset + local_offset) + 1] - (int)rgba_u8_ref[(block_offset + local_offset) + 1])*((int)rgba_u8[1][i][(block_offset + local_offset) + 1] - (int)rgba_u8_ref[(block_offset + local_offset) + 1]);
							blockerr1[(y/4)*(width/4) + x/4] += ((int)rgba_u8[1][i][(block_offset + local_offset) + 2] - (int)rgba_u8_ref[(block_offset + local_offset) + 2])*((int)rgba_u8[1][i][(block_offset + local_offset) + 2] - (int)rgba_u8_ref[(block_offset + local_offset) + 2]);
						}
				}
			float largest_error = 0.0f;
			int lx = 0, ly = 0;
			float total_block_err0 = 0.0f;
			float total_block_err1 = 0.0f;
			for (int y = 0; y < height; y+=4)
				for (int x = 0; x < width; x+=4)
				{
					total_block_err0 += blockerr0[(y/4)*(width/4) + x/4];
					total_block_err1 += blockerr1[(y/4)*(width/4) + x/4];

					if (blockerr1[(y/4)*(width/4) + x/4] < blockerr0[(y/4)*(width/4) + x/4])
					{
						bad_blocks++;
						if (i == 0)
						{
							//printf("x,y: (%5i %5i) %f < %f (%f)\n", x, y, blockerr1[(y/4)*(width/4) + x/4], blockerr0[(y/4)*(width/4) + x/4], blockerr1[(y/4)*(width/4) + x/4] - blockerr0[(y/4)*(width/4) + x/4]);
							if (fabsf(blockerr1[(y/4)*(width/4) + x/4] - blockerr0[(y/4)*(width/4) + x/4]) > largest_error)
							{
								largest_error = fabsf(blockerr1[(y/4)*(width/4) + x/4] - blockerr0[(y/4)*(width/4) + x/4]);
								lx = x;
								ly = y;
							}
						}
					}
				}
			printf("largest error: %f @ %5i %5i\n", largest_error, lx, ly);
			printf("lower quality blocks: %i (%.2f%%)\n", bad_blocks, 100.0 * bad_blocks / (double)total_blocks);
			for (j = 0; j < width * height; j++)
			{
				tlerr0 += lerr0[j];
				tlerr1 += lerr1[j];
			}

			{
				//float lx, cx, sx;
				//DDS_SSIM(rgba_u8_ref, rgba_u8[0][i], width, height, 0, 0, 999999, &lx, &cx, &sx);
				//printf("SSIM: %f %f %f -> %f\n", lx, cx, sx, lx * cx * sx);
			}
			
			printf("error: %f vs %f (%i vs %i)\n", error0, error1, count0, count1);
			printf("MSE: %f vs %f (%f vs %f, %f vs %f)\n", error0 / count0, error1 / count1, tlerr0 / count0, tlerr1 / count1, total_block_err0 / count0, total_block_err1 / count1);
			printf("PSNR: %f vs %f\n", 10.0 * log10(255.0f * 255.0f / (error0 / count0)), 10.0 * log10(255.0f * 255.0f / (error1 / count1)));
			printf("Alpha MSE: %f vs %f\n", alpha_error0 / alpha_count0, alpha_error1 / alpha_count1);
			printf("Alpha PSNR: %f vs %f\n", 10.0 * log10(255.0f * 255.0f / (alpha_error0 / alpha_count0)), 10.0 * log10(255.0f * 255.0f / (alpha_error1 / alpha_count1)));

		}
		if (i == 0)
		{
			printf("errsum: %f\n", errsum);
			exit(0);
		}
	}

	//exit(0);
}

void DDS_ComputeMaps()
{
	return;
	int map5[][3] = {
		{ 0,  0,   0},
		{-1, -1,   1},
		{-1, -1,   2},
		{ 0,  1,   3},
		{-1, -1,   4},
		{ 1,  0,   5},
		{-1, -1,   6},
		{-1, -1,   7},
		{ 1,  1,   8},
		{-1, -1,   9},
		{-1, -1,  10},
		{ 1,  2,  11},
		{-1, -1,  12},
		{ 2,  1,  13},
		{ 0,  5,  14},
		{-1, -1,  15},
		{ 2,  2,  16},
		{-1, -1,  17},
		{-1, -1,  18},
		{ 2,  3,  19},
		{-1, -1,  20},
		{ 3,  2,  21},
		{ 2,  4,  22},
		{-1, -1,  23},
		{ 3,  3,  24},
		{ 4,  1,  25},
		{-1, -1,  26},
		{ 3,  4,  27},
		{-1, -1,  28},
		{-1, -1,  29},
		{ 4,  3,  30},
		{-1, -1,  31},
		{ 3,  6,  32},
		{ 4,  4,  33},
		{-1, -1,  34},
		{ 5,  3,  35},
		{ 4,  5,  36},
		{-1, -1,  37},
		{ 5,  4,  38},
		{-1, -1,  39},
		{-1, -1,  40},
		{ 5,  5,  41},
		{-1, -1,  42},
		{ 7,  2,  43},
		{ 5,  6,  44},
		{-1, -1,  45},
		{ 6,  5,  46},
		{ 4,  9,  47},
		{-1, -1,  48},
		{ 6,  6,  49},
		{-1, -1,  50},
		{-1, -1,  51},
		{ 6,  7,  52},
		{-1, -1,  53},
		{ 7,  6,  54},
		{ 6,  8,  55},
		{-1, -1,  56},
		{ 7,  7,  57},
		{ 8,  5,  58},
		{-1, -1,  59},
		{ 7,  8,  60},
		{-1, -1,  61},
		{-1, -1,  62},
		{ 8,  7,  63},
		{-1, -1,  64},
		{ 7, 10,  65},
		{ 8,  8,  66},
		{-1, -1,  67},
		{ 9,  7,  68},
		{ 8,  9,  69},
		{-1, -1,  70},
		{ 9,  8,  71},
		{-1, -1,  72},
		{-1, -1,  73},
		{ 9,  9,  74},
		{-1, -1,  75},
		{11,  6,  76},
		{ 9, 10,  77},
		{-1, -1,  78},
		{10,  9,  79},
		{ 8, 13,  80},
		{-1, -1,  81},
		{10, 10,  82},
		{-1, -1,  83},
		{-1, -1,  84},
		{10, 11,  85},
		{-1, -1,  86},
		{11, 10,  87},
		{10, 12,  88},
		{-1, -1,  89},
		{11, 11,  90},
		{12,  9,  91},
		{-1, -1,  92},
		{11, 12,  93},
		{-1, -1,  94},
		{-1, -1,  95},
		{12, 11,  96},
		{-1, -1,  97},
		{11, 14,  98},
		{12, 12,  99},
		{-1, -1, 100},
		{13, 11, 101},
		{12, 13, 102},
		{-1, -1, 103},
		{13, 12, 104},
		{-1, -1, 105},
		{-1, -1, 106},
		{13, 13, 107},
		{-1, -1, 108},
		{15, 10, 109},
		{13, 14, 110},
		{-1, -1, 111},
		{14, 13, 112},
		{12, 17, 113},
		{-1, -1, 114},
		{14, 14, 115},
		{-1, -1, 116},
		{-1, -1, 117},
		{14, 15, 118},
		{-1, -1, 119},
		{15, 14, 120},
		{14, 16, 121},
		{-1, -1, 122},
		{15, 15, 123},
		{16, 13, 124},
		{-1, -1, 125},
		{15, 16, 126},
		{-1, -1, 127},
		{-1, -1, 128},
		{16, 15, 129},
		{-1, -1, 130},
		{15, 18, 131},
		{16, 16, 132},
		{-1, -1, 133},
		{17, 15, 134},
		{16, 17, 135},
		{-1, -1, 136},
		{17, 16, 137},
		{-1, -1, 138},
		{-1, -1, 139},
		{17, 17, 140},
		{-1, -1, 141},
		{19, 14, 142},
		{17, 18, 143},
		{-1, -1, 144},
		{18, 17, 145},
		{16, 21, 146},
		{-1, -1, 147},
		{18, 18, 148},
		{-1, -1, 149},
		{-1, -1, 150},
		{18, 19, 151},
		{-1, -1, 152},
		{19, 18, 153},
		{18, 20, 154},
		{-1, -1, 155},
		{19, 19, 156},
		{20, 17, 157},
		{-1, -1, 158},
		{19, 20, 159},
		{-1, -1, 160},
		{-1, -1, 161},
		{20, 19, 162},
		{-1, -1, 163},
		{19, 22, 164},
		{20, 20, 165},
		{-1, -1, 166},
		{21, 19, 167},
		{20, 21, 168},
		{-1, -1, 169},
		{21, 20, 170},
		{-1, -1, 171},
		{-1, -1, 172},
		{21, 21, 173},
		{-1, -1, 174},
		{23, 18, 175},
		{21, 22, 176},
		{-1, -1, 177},
		{22, 21, 178},
		{20, 25, 179},
		{-1, -1, 180},
		{22, 22, 181},
		{-1, -1, 182},
		{-1, -1, 183},
		{22, 23, 184},
		{-1, -1, 185},
		{23, 22, 186},
		{22, 24, 187},
		{-1, -1, 188},
		{23, 23, 189},
		{24, 21, 190},
		{-1, -1, 191},
		{23, 24, 192},
		{-1, -1, 193},
		{-1, -1, 194},
		{24, 23, 195},
		{-1, -1, 196},
		{23, 26, 197},
		{24, 24, 198},
		{-1, -1, 199},
		{25, 23, 200},
		{24, 25, 201},
		{-1, -1, 202},
		{25, 24, 203},
		{-1, -1, 204},
		{-1, -1, 205},
		{25, 25, 206},
		{-1, -1, 207},
		{27, 22, 208},
		{25, 26, 209},
		{-1, -1, 210},
		{26, 25, 211},
		{24, 29, 212},
		{-1, -1, 213},
		{26, 26, 214},
		{-1, -1, 215},
		{-1, -1, 216},
		{26, 27, 217},
		{-1, -1, 218},
		{27, 26, 219},
		{26, 28, 220},
		{-1, -1, 221},
		{27, 27, 222},
		{28, 25, 223},
		{-1, -1, 224},
		{27, 28, 225},
		{-1, -1, 226},
		{-1, -1, 227},
		{28, 27, 228},
		{-1, -1, 229},
		{27, 30, 230},
		{28, 28, 231},
		{-1, -1, 232},
		{29, 27, 233},
		{28, 29, 234},
		{-1, -1, 235},
		{29, 28, 236},
		{-1, -1, 237},
		{-1, -1, 238},
		{29, 29, 239},
		{-1, -1, 240},
		{31, 26, 241},
		{29, 30, 242},
		{-1, -1, 243},
		{30, 29, 244},
		{-1, -1, 245},
		{-1, -1, 246},
		{30, 30, 247},
		{-1, -1, 248},
		{-1, -1, 249},
		{30, 31, 250},
		{-1, -1, 251},
		{31, 30, 252},
		{-1, -1, 253},
		{-1, -1, 254},
		{31, 31, 255}};

	
	int map6[][3] = {
	{ 0,  0,   0},
	{ 0,  1,   1},
	{-1, -1,   2},
	{ 1,  0,   3},
	{ 1,  1,   4},
	{ 1,  2,   5},
	{-1, -1,   6},
	{ 2,  1,   7},
	{ 2,  2,   8},
	{ 2,  3,   9},
	{-1, -1,  10},
	{ 3,  2,  11},
	{ 3,  3,  12},
	{ 3,  4,  13},
	{-1, -1,  14},
	{ 4,  3,  15},
	{ 4,  4,  16},
	{ 4,  5,  17},
	{-1, -1,  18},
	{ 5,  4,  19},
	{ 5,  5,  20},
	{ 5,  6,  21},
	{ 0, 16,  22},
	{ 6,  5,  23},
	{ 6,  6,  24},
	{ 6,  7,  25},
	{ 1, 17,  26},
	{ 7,  6,  27},
	{ 7,  7,  28},
	{ 7,  8,  29},
	{ 3, 16,  30},
	{ 8,  7,  31},
	{ 8,  8,  32},
	{ 8,  9,  33},
	{ 4, 17,  34},
	{ 9,  8,  35},
	{ 9,  9,  36},
	{ 9, 10,  37},
	{ 6, 16,  38},
	{10,  9,  39},
	{10, 10,  40},
	{10, 11,  41},
	{ 7, 17,  42},
	{11, 10,  43},
	{11, 11,  44},
	{11, 12,  45},
	{ 9, 16,  46},
	{12, 11,  47},
	{12, 12,  48},
	{12, 13,  49},
	{10, 17,  50},
	{13, 12,  51},
	{13, 13,  52},
	{13, 14,  53},
	{12, 16,  54},
	{14, 13,  55},
	{14, 14,  56},
	{14, 15,  57},
	{13, 17,  58},
	{15, 14,  59},
	{15, 15,  60},
	{16, 13,  61},
	{15, 16,  62},
	{16, 15,  63},
	{15, 18,  64},
	{16, 16,  65},
	{16, 17,  66},
	{18, 14,  67},
	{17, 16,  68},
	{17, 17,  69},
	{17, 18,  70},
	{19, 15,  71},
	{18, 17,  72},
	{18, 18,  73},
	{18, 19,  74},
	{21, 14,  75},
	{19, 18,  76},
	{19, 19,  77},
	{19, 20,  78},
	{22, 15,  79},
	{20, 19,  80},
	{20, 20,  81},
	{20, 21,  82},
	{24, 14,  83},
	{21, 20,  84},
	{21, 21,  85},
	{21, 22,  86},
	{25, 15,  87},
	{22, 21,  88},
	{22, 22,  89},
	{22, 23,  90},
	{27, 14,  91},
	{23, 22,  92},
	{23, 23,  93},
	{23, 24,  94},
	{19, 32,  95},
	{24, 23,  96},
	{24, 24,  97},
	{24, 25,  98},
	{20, 33,  99},
	{25, 24, 100},
	{25, 25, 101},
	{25, 26, 102},
	{22, 32, 103},
	{26, 25, 104},
	{26, 26, 105},
	{26, 27, 106},
	{23, 33, 107},
	{27, 26, 108},
	{27, 27, 109},
	{27, 28, 110},
	{25, 32, 111},
	{28, 27, 112},
	{28, 28, 113},
	{28, 29, 114},
	{26, 33, 115},
	{29, 28, 116},
	{29, 29, 117},
	{29, 30, 118},
	{28, 32, 119},
	{30, 29, 120},
	{30, 30, 121},
	{30, 31, 122},
	{29, 33, 123},
	{31, 30, 124},
	{31, 31, 125},
	{32, 29, 126},
	{31, 32, 127},
	{32, 31, 128},
	{31, 34, 129},
	{32, 32, 130},
	{32, 33, 131},
	{34, 30, 132},
	{33, 32, 133},
	{33, 33, 134},
	{33, 34, 135},
	{35, 31, 136},
	{34, 33, 137},
	{34, 34, 138},
	{34, 35, 139},
	{37, 30, 140},
	{35, 34, 141},
	{35, 35, 142},
	{35, 36, 143},
	{38, 31, 144},
	{36, 35, 145},
	{36, 36, 146},
	{36, 37, 147},
	{40, 30, 148},
	{37, 36, 149},
	{37, 37, 150},
	{37, 38, 151},
	{41, 31, 152},
	{38, 37, 153},
	{38, 38, 154},
	{38, 39, 155},
	{43, 30, 156},
	{39, 38, 157},
	{39, 39, 158},
	{39, 40, 159},
	{35, 48, 160},
	{40, 39, 161},
	{40, 40, 162},
	{40, 41, 163},
	{36, 49, 164},
	{41, 40, 165},
	{41, 41, 166},
	{41, 42, 167},
	{38, 48, 168},
	{42, 41, 169},
	{42, 42, 170},
	{42, 43, 171},
	{39, 49, 172},
	{43, 42, 173},
	{43, 43, 174},
	{43, 44, 175},
	{41, 48, 176},
	{44, 43, 177},
	{44, 44, 178},
	{44, 45, 179},
	{42, 49, 180},
	{45, 44, 181},
	{45, 45, 182},
	{45, 46, 183},
	{44, 48, 184},
	{46, 45, 185},
	{46, 46, 186},
	{46, 47, 187},
	{45, 49, 188},
	{47, 46, 189},
	{47, 47, 190},
	{48, 45, 191},
	{47, 48, 192},
	{48, 47, 193},
	{47, 50, 194},
	{48, 48, 195},
	{48, 49, 196},
	{50, 46, 197},
	{49, 48, 198},
	{49, 49, 199},
	{49, 50, 200},
	{51, 47, 201},
	{50, 49, 202},
	{50, 50, 203},
	{50, 51, 204},
	{53, 46, 205},
	{51, 50, 206},
	{51, 51, 207},
	{51, 52, 208},
	{54, 47, 209},
	{52, 51, 210},
	{52, 52, 211},
	{52, 53, 212},
	{56, 46, 213},
	{53, 52, 214},
	{53, 53, 215},
	{53, 54, 216},
	{57, 47, 217},
	{54, 53, 218},
	{54, 54, 219},
	{54, 55, 220},
	{59, 46, 221},
	{55, 54, 222},
	{55, 55, 223},
	{55, 56, 224},
	{60, 47, 225},
	{56, 55, 226},
	{56, 56, 227},
	{56, 57, 228},
	{62, 46, 229},
	{57, 56, 230},
	{57, 57, 231},
	{57, 58, 232},
	{63, 47, 233},
	{58, 57, 234},
	{58, 58, 235},
	{58, 59, 236},
	{-1, -1, 237},
	{59, 58, 238},
	{59, 59, 239},
	{59, 60, 240},
	{-1, -1, 241},
	{60, 59, 242},
	{60, 60, 243},
	{60, 61, 244},
	{-1, -1, 245},
	{61, 60, 246},
	{61, 61, 247},
	{61, 62, 248},
	{-1, -1, 249},
	{62, 61, 250},
	{62, 62, 251},
	{62, 63, 252},
	{-1, -1, 253},
	{63, 62, 254},
	{63, 63, 255}};

	int map5_index2[][3] = 
	{
		{ 0,  0,   0},
		{-1, -1,   1},
		{-1, -1,   2},
		{ 1,  0,   3},
		{-1, -1,   4},
		{ 0,  1,   5},
		{-1, -1,   6},
		{-1, -1,   7},
		{ 1,  1,   8},
		{-1, -1,   9},
		{-1, -1,  10},
		{ 2,  1,  11},
		{-1, -1,  12},
		{ 1,  2,  13},
		{ 5,  0,  14},
		{-1, -1,  15},
		{ 2,  2,  16},
		{-1, -1,  17},
		{-1, -1,  18},
		{ 3,  2,  19},
		{-1, -1,  20},
		{ 2,  3,  21},
		{ 4,  2,  22},
		{-1, -1,  23},
		{ 3,  3,  24},
		{ 1,  4,  25},
		{-1, -1,  26},
		{ 4,  3,  27},
		{-1, -1,  28},
		{-1, -1,  29},
		{ 3,  4,  30},
		{-1, -1,  31},
		{ 6,  3,  32},
		{ 4,  4,  33},
		{-1, -1,  34},
		{ 3,  5,  35},
		{ 5,  4,  36},
		{-1, -1,  37},
		{ 4,  5,  38},
		{-1, -1,  39},
		{-1, -1,  40},
		{ 5,  5,  41},
		{-1, -1,  42},
		{ 2,  7,  43},
		{ 6,  5,  44},
		{-1, -1,  45},
		{ 5,  6,  46},
		{ 9,  4,  47},
		{-1, -1,  48},
		{ 6,  6,  49},
		{-1, -1,  50},
		{-1, -1,  51},
		{ 7,  6,  52},
		{-1, -1,  53},
		{ 6,  7,  54},
		{ 8,  6,  55},
		{-1, -1,  56},
		{ 7,  7,  57},
		{ 5,  8,  58},
		{-1, -1,  59},
		{ 8,  7,  60},
		{-1, -1,  61},
		{-1, -1,  62},
		{ 7,  8,  63},
		{-1, -1,  64},
		{10,  7,  65},
		{ 8,  8,  66},
		{-1, -1,  67},
		{ 7,  9,  68},
		{ 9,  8,  69},
		{-1, -1,  70},
		{ 8,  9,  71},
		{-1, -1,  72},
		{-1, -1,  73},
		{ 9,  9,  74},
		{-1, -1,  75},
		{ 6, 11,  76},
		{10,  9,  77},
		{-1, -1,  78},
		{ 9, 10,  79},
		{13,  8,  80},
		{-1, -1,  81},
		{10, 10,  82},
		{-1, -1,  83},
		{-1, -1,  84},
		{11, 10,  85},
		{-1, -1,  86},
		{10, 11,  87},
		{12, 10,  88},
		{-1, -1,  89},
		{11, 11,  90},
		{ 9, 12,  91},
		{-1, -1,  92},
		{12, 11,  93},
		{-1, -1,  94},
		{-1, -1,  95},
		{11, 12,  96},
		{-1, -1,  97},
		{14, 11,  98},
		{12, 12,  99},
		{-1, -1, 100},
		{11, 13, 101},
		{13, 12, 102},
		{-1, -1, 103},
		{12, 13, 104},
		{-1, -1, 105},
		{-1, -1, 106},
		{13, 13, 107},
		{-1, -1, 108},
		{10, 15, 109},
		{14, 13, 110},
		{-1, -1, 111},
		{13, 14, 112},
		{17, 12, 113},
		{-1, -1, 114},
		{14, 14, 115},
		{-1, -1, 116},
		{-1, -1, 117},
		{15, 14, 118},
		{-1, -1, 119},
		{14, 15, 120},
		{16, 14, 121},
		{-1, -1, 122},
		{15, 15, 123},
		{13, 16, 124},
		{-1, -1, 125},
		{16, 15, 126},
		{-1, -1, 127},
		{-1, -1, 128},
		{15, 16, 129},
		{-1, -1, 130},
		{18, 15, 131},
		{16, 16, 132},
		{-1, -1, 133},
		{15, 17, 134},
		{17, 16, 135},
		{-1, -1, 136},
		{16, 17, 137},
		{-1, -1, 138},
		{-1, -1, 139},
		{17, 17, 140},
		{-1, -1, 141},
		{14, 19, 142},
		{18, 17, 143},
		{-1, -1, 144},
		{17, 18, 145},
		{21, 16, 146},
		{-1, -1, 147},
		{18, 18, 148},
		{-1, -1, 149},
		{-1, -1, 150},
		{19, 18, 151},
		{-1, -1, 152},
		{18, 19, 153},
		{20, 18, 154},
		{-1, -1, 155},
		{19, 19, 156},
		{17, 20, 157},
		{-1, -1, 158},
		{20, 19, 159},
		{-1, -1, 160},
		{-1, -1, 161},
		{19, 20, 162},
		{-1, -1, 163},
		{22, 19, 164},
		{20, 20, 165},
		{-1, -1, 166},
		{19, 21, 167},
		{21, 20, 168},
		{-1, -1, 169},
		{20, 21, 170},
		{-1, -1, 171},
		{-1, -1, 172},
		{21, 21, 173},
		{-1, -1, 174},
		{18, 23, 175},
		{22, 21, 176},
		{-1, -1, 177},
		{21, 22, 178},
		{25, 20, 179},
		{-1, -1, 180},
		{22, 22, 181},
		{-1, -1, 182},
		{-1, -1, 183},
		{23, 22, 184},
		{-1, -1, 185},
		{22, 23, 186},
		{24, 22, 187},
		{-1, -1, 188},
		{23, 23, 189},
		{21, 24, 190},
		{-1, -1, 191},
		{24, 23, 192},
		{-1, -1, 193},
		{-1, -1, 194},
		{23, 24, 195},
		{-1, -1, 196},
		{26, 23, 197},
		{24, 24, 198},
		{-1, -1, 199},
		{23, 25, 200},
		{25, 24, 201},
		{-1, -1, 202},
		{24, 25, 203},
		{-1, -1, 204},
		{-1, -1, 205},
		{25, 25, 206},
		{-1, -1, 207},
		{22, 27, 208},
		{26, 25, 209},
		{-1, -1, 210},
		{25, 26, 211},
		{29, 24, 212},
		{-1, -1, 213},
		{26, 26, 214},
		{-1, -1, 215},
		{-1, -1, 216},
		{27, 26, 217},
		{-1, -1, 218},
		{26, 27, 219},
		{28, 26, 220},
		{-1, -1, 221},
		{27, 27, 222},
		{25, 28, 223},
		{-1, -1, 224},
		{28, 27, 225},
		{-1, -1, 226},
		{-1, -1, 227},
		{27, 28, 228},
		{-1, -1, 229},
		{30, 27, 230},
		{28, 28, 231},
		{-1, -1, 232},
		{27, 29, 233},
		{29, 28, 234},
		{-1, -1, 235},
		{28, 29, 236},
		{-1, -1, 237},
		{-1, -1, 238},
		{29, 29, 239},
		{-1, -1, 240},
		{26, 31, 241},
		{30, 29, 242},
		{-1, -1, 243},
		{29, 30, 244},
		{-1, -1, 245},
		{-1, -1, 246},
		{30, 30, 247},
		{-1, -1, 248},
		{-1, -1, 249},
		{31, 30, 250},
		{-1, -1, 251},
		{30, 31, 252},
		{-1, -1, 253},
		{-1, -1, 254},
		{31, 31, 255}
	};


	int map6_index2[][3] =
	{
		{ 0,  0,   0},
		{ 1,  0,   1},
		{-1, -1,   2},
		{ 0,  1,   3},
		{ 1,  1,   4},
		{ 2,  1,   5},
		{-1, -1,   6},
		{ 1,  2,   7},
		{ 2,  2,   8},
		{ 3,  2,   9},
		{-1, -1,  10},
		{ 2,  3,  11},
		{ 3,  3,  12},
		{ 4,  3,  13},
		{-1, -1,  14},
		{ 3,  4,  15},
		{ 4,  4,  16},
		{ 5,  4,  17},
		{-1, -1,  18},
		{ 4,  5,  19},
		{ 5,  5,  20},
		{ 6,  5,  21},
		{16,  0,  22},
		{ 5,  6,  23},
		{ 6,  6,  24},
		{ 7,  6,  25},
		{17,  1,  26},
		{ 6,  7,  27},
		{ 7,  7,  28},
		{ 8,  7,  29},
		{16,  3,  30},
		{ 7,  8,  31},
		{ 8,  8,  32},
		{ 9,  8,  33},
		{17,  4,  34},
		{ 8,  9,  35},
		{ 9,  9,  36},
		{10,  9,  37},
		{16,  6,  38},
		{ 9, 10,  39},
		{10, 10,  40},
		{11, 10,  41},
		{17,  7,  42},
		{10, 11,  43},
		{11, 11,  44},
		{12, 11,  45},
		{16,  9,  46},
		{11, 12,  47},
		{12, 12,  48},
		{13, 12,  49},
		{17, 10,  50},
		{12, 13,  51},
		{13, 13,  52},
		{14, 13,  53},
		{16, 12,  54},
		{13, 14,  55},
		{14, 14,  56},
		{15, 14,  57},
		{17, 13,  58},
		{14, 15,  59},
		{15, 15,  60},
		{13, 16,  61},
		{16, 15,  62},
		{15, 16,  63},
		{18, 15,  64},
		{16, 16,  65},
		{17, 16,  66},
		{14, 18,  67},
		{16, 17,  68},
		{17, 17,  69},
		{18, 17,  70},
		{15, 19,  71},
		{17, 18,  72},
		{18, 18,  73},
		{19, 18,  74},
		{14, 21,  75},
		{18, 19,  76},
		{19, 19,  77},
		{20, 19,  78},
		{15, 22,  79},
		{19, 20,  80},
		{20, 20,  81},
		{21, 20,  82},
		{14, 24,  83},
		{20, 21,  84},
		{21, 21,  85},
		{22, 21,  86},
		{15, 25,  87},
		{21, 22,  88},
		{22, 22,  89},
		{23, 22,  90},
		{14, 27,  91},
		{22, 23,  92},
		{23, 23,  93},
		{24, 23,  94},
		{15, 28,  95},
		{23, 24,  96},
		{24, 24,  97},
		{25, 24,  98},
		{33, 20,  99},
		{24, 25, 100},
		{25, 25, 101},
		{26, 25, 102},
		{32, 22, 103},
		{25, 26, 104},
		{26, 26, 105},
		{27, 26, 106},
		{33, 23, 107},
		{26, 27, 108},
		{27, 27, 109},
		{28, 27, 110},
		{32, 25, 111},
		{27, 28, 112},
		{28, 28, 113},
		{29, 28, 114},
		{33, 26, 115},
		{28, 29, 116},
		{29, 29, 117},
		{30, 29, 118},
		{32, 28, 119},
		{29, 30, 120},
		{30, 30, 121},
		{31, 30, 122},
		{33, 29, 123},
		{30, 31, 124},
		{31, 31, 125},
		{29, 32, 126},
		{32, 31, 127},
		{31, 32, 128},
		{34, 31, 129},
		{32, 32, 130},
		{33, 32, 131},
		{30, 34, 132},
		{32, 33, 133},
		{33, 33, 134},
		{34, 33, 135},
		{31, 35, 136},
		{33, 34, 137},
		{34, 34, 138},
		{35, 34, 139},
		{30, 37, 140},
		{34, 35, 141},
		{35, 35, 142},
		{36, 35, 143},
		{31, 38, 144},
		{35, 36, 145},
		{36, 36, 146},
		{37, 36, 147},
		{30, 40, 148},
		{36, 37, 149},
		{37, 37, 150},
		{38, 37, 151},
		{31, 41, 152},
		{37, 38, 153},
		{38, 38, 154},
		{39, 38, 155},
		{30, 43, 156},
		{38, 39, 157},
		{39, 39, 158},
		{40, 39, 159},
		{31, 44, 160},
		{39, 40, 161},
		{40, 40, 162},
		{41, 40, 163},
		{49, 36, 164},
		{40, 41, 165},
		{41, 41, 166},
		{42, 41, 167},
		{48, 38, 168},
		{41, 42, 169},
		{42, 42, 170},
		{43, 42, 171},
		{49, 39, 172},
		{42, 43, 173},
		{43, 43, 174},
		{44, 43, 175},
		{48, 41, 176},
		{43, 44, 177},
		{44, 44, 178},
		{45, 44, 179},
		{49, 42, 180},
		{44, 45, 181},
		{45, 45, 182},
		{46, 45, 183},
		{48, 44, 184},
		{45, 46, 185},
		{46, 46, 186},
		{47, 46, 187},
		{49, 45, 188},
		{46, 47, 189},
		{47, 47, 190},
		{45, 48, 191},
		{48, 47, 192},
		{47, 48, 193},
		{50, 47, 194},
		{48, 48, 195},
		{49, 48, 196},
		{46, 50, 197},
		{48, 49, 198},
		{49, 49, 199},
		{50, 49, 200},
		{47, 51, 201},
		{49, 50, 202},
		{50, 50, 203},
		{51, 50, 204},
		{46, 53, 205},
		{50, 51, 206},
		{51, 51, 207},
		{52, 51, 208},
		{47, 54, 209},
		{51, 52, 210},
		{52, 52, 211},
		{53, 52, 212},
		{46, 56, 213},
		{52, 53, 214},
		{53, 53, 215},
		{54, 53, 216},
		{47, 57, 217},
		{53, 54, 218},
		{54, 54, 219},
		{55, 54, 220},
		{46, 59, 221},
		{54, 55, 222},
		{55, 55, 223},
		{56, 55, 224},
		{47, 60, 225},
		{55, 56, 226},
		{56, 56, 227},
		{57, 56, 228},
		{46, 62, 229},
		{56, 57, 230},
		{57, 57, 231},
		{58, 57, 232},
		{47, 63, 233},
		{57, 58, 234},
		{58, 58, 235},
		{59, 58, 236},
		{-1, -1, 237},
		{58, 59, 238},
		{59, 59, 239},
		{60, 59, 240},
		{-1, -1, 241},
		{59, 60, 242},
		{60, 60, 243},
		{61, 60, 244},
		{-1, -1, 245},
		{60, 61, 246},
		{61, 61, 247},
		{62, 61, 248},
		{-1, -1, 249},
		{61, 62, 250},
		{62, 62, 251},
		{63, 62, 252},
		{-1, -1, 253},
		{62, 63, 254},
		{63, 63, 255}
	};
	/*{{0, 0, 0}, {0, 1, 1}, {-1, -1, -1}, {1, 0, 3}, {1, 1, 4}, {2, 0, 
		5}, {-1, -1, -1}, {2, 1, 7}, {3, 0, 8}, {3, 1, 9}, {-1, -1, -1}, {4,
		0, 11}, {4, 1, 12}, {5, 0, 13}, {-1, -1, -1}, {5, 1, 15}, {6, 0, 
		16}, {6, 1, 17}, {-1, -1, -1}, {7, 0, 19}, {7, 1, 20}, {8, 0, 
		21}, {0, 16, 22}, {8, 1, 23}, {9, 0, 24}, {9, 1, 25}, {1, 17, 
		26}, {10, 0, 27}, {10, 1, 28}, {11, 0, 29}, {3, 16, 30}, {11, 1, 
		31}, {12, 0, 32}, {12, 1, 33}, {4, 17, 34}, {13, 0, 35}, {13, 1, 
		36}, {14, 0, 37}, {6, 16, 38}, {14, 1, 39}, {15, 0, 40}, {15, 1, 
		41}, {7, 17, 42}, {16, 0, 43}, {15, 3, 44}, {16, 1, 45}, {17, 0, 
		46}, {17, 1, 47}, {15, 6, 48}, {18, 0, 49}, {18, 1, 50}, {19, 0, 
		51}, {15, 9, 52}, {19, 1, 53}, {20, 0, 54}, {20, 1, 55}, {15, 12, 
		56}, {21, 0, 57}, {21, 1, 58}, {22, 0, 59}, {15, 15, 60}, {22, 1, 
		61}, {23, 0, 62}, {23, 1, 63}, {15, 18, 64}, {24, 0, 65}, {24, 1, 
		66}, {25, 0, 67}, {17, 16, 68}, {25, 1, 69}, {26, 0, 70}, {26, 1, 
		71}, {18, 17, 72}, {27, 0, 73}, {27, 1, 74}, {28, 0, 75}, {20, 16, 
		76}, {28, 1, 77}, {29, 0, 78}, {29, 1, 79}, {21, 17, 80}, {30, 0, 
		81}, {30, 1, 82}, {31, 0, 83}, {23, 16, 84}, {31, 1, 85}, {31, 2, 
		86}, {32, 0, 87}, {32, 1, 88}, {33, 0, 89}, {31, 5, 90}, {33, 1, 
		91}, {34, 0, 92}, {34, 1, 93}, {31, 8, 94}, {35, 0, 95}, {35, 1, 
		96}, {36, 0, 97}, {31, 11, 98}, {36, 1, 99}, {37, 0, 100}, {37, 1, 
		101}, {31, 14, 102}, {38, 0, 103}, {38, 1, 104}, {39, 0, 105}, {31, 
		17, 106}, {39, 1, 107}, {40, 0, 108}, {40, 1, 109}, {32, 17, 
		110}, {41, 0, 111}, {41, 1, 112}, {42, 0, 113}, {34, 16, 114}, {42, 
		1, 115}, {43, 0, 116}, {43, 1, 117}, {35, 17, 118}, {44, 0, 
		119}, {44, 1, 120}, {45, 0, 121}, {37, 16, 122}, {45, 1, 123}, {46, 
		0, 124}, {46, 1, 125}, {38, 17, 126}, {47, 0, 127}, {47, 1, 
		128}, {47, 2, 129}, {48, 0, 130}, {48, 1, 131}, {47, 4, 132}, {49, 
		0, 133}, {49, 1, 134}, {50, 0, 135}, {47, 7, 136}, {50, 1, 
		137}, {51, 0, 138}, {51, 1, 139}, {47, 10, 140}, {52, 0, 141}, {52, 
		1, 142}, {53, 0, 143}, {47, 13, 144}, {53, 1, 145}, {54, 0, 
		146}, {54, 1, 147}, {47, 16, 148}, {55, 0, 149}, {55, 1, 150}, {56, 
		0, 151}, {48, 16, 152}, {56, 1, 153}, {57, 0, 154}, {57, 1, 
		155}, {49, 17, 156}, {58, 0, 157}, {58, 1, 158}, {59, 0, 159}, {51, 
		16, 160}, {59, 1, 161}, {60, 0, 162}, {60, 1, 163}, {52, 17, 
		164}, {61, 0, 165}, {61, 1, 166}, {62, 0, 167}, {54, 16, 168}, {62, 
		1, 169}, {63, 0, 170}, {63, 1, 171}, {55, 17, 172}, {63, 2, 
		173}, {63, 3, 174}, {63, 4, 175}, {57, 16, 176}, {63, 5, 177}, {63, 
		6, 178}, {63, 7, 179}, {58, 17, 180}, {63, 8, 181}, {63, 9, 
		182}, {63, 10, 183}, {60, 16, 184}, {63, 11, 185}, {63, 12, 
		186}, {63, 13, 187}, {61, 17, 188}, {63, 14, 189}, {63, 15, 
		190}, {54, 33, 191}, {63, 16, 192}, {63, 17, 193}, {63, 18, 
		194}, {56, 32, 195}, {63, 19, 196}, {63, 20, 197}, {63, 21, 
		198}, {57, 33, 199}, {63, 22, 200}, {63, 23, 201}, {63, 24, 
		202}, {59, 32, 203}, {63, 25, 204}, {63, 26, 205}, {63, 27, 
		206}, {60, 33, 207}, {63, 28, 208}, {63, 29, 209}, {63, 30, 
		210}, {62, 32, 211}, {63, 31, 212}, {63, 32, 213}, {55, 48, 
		214}, {63, 33, 215}, {63, 34, 216}, {63, 35, 217}, {56, 49, 
		218}, {63, 36, 219}, {63, 37, 220}, {63, 38, 221}, {58, 48, 
		222}, {63, 39, 223}, {63, 40, 224}, {63, 41, 225}, {59, 49, 
		226}, {63, 42, 227}, {63, 43, 228}, {63, 44, 229}, {61, 48, 
		230}, {63, 45, 231}, {63, 46, 232}, {63, 47, 233}, {62, 49, 
		234}, {63, 48, 235}, {63, 49, 236}, {-1, -1, -1}, {63, 50, 
		238}, {63, 51, 239}, {63, 52, 240}, {-1, -1, -1}, {63, 53, 
		242}, {63, 54, 243}, {63, 55, 244}, {-1, -1, -1}, {63, 56, 
		246}, {63, 57, 247}, {63, 58, 248}, {-1, -1, -1}, {63, 59, 
		250}, {63, 60, 251}, {63, 61, 252}, {-1, -1, -1}, {63, 62, 
		254}, {63, 63, 255}};
	*/
	int i;
	int j;
	int out_map5[256][3];
	int out_map6[256][3];

	for (i = 0; i < 256; i++)
	{
		if (map5[i][0] == -1)
		{
			int best_err = 999999999;
			int best_index = 0;
			for (j = 0; j < 256; j++)
			{
				if (map5[j][0] != -1)
				{
					if ((map5[j][2] - i)*(map5[j][2] - i) < best_err)
					{
						best_err = (map5[j][2] - i)*(map5[j][2] - i);
						best_index = j;
					}
				}
			}
			out_map5[i][0] = map5[best_index][0];
			out_map5[i][1] = map5[best_index][1];
			out_map5[i][2] = map5[best_index][2];
		}
		else
		{
			out_map5[i][0] = map5[i][0];
			out_map5[i][1] = map5[i][1];
			out_map5[i][2] = map5[i][2];
		}
		if (map6[i][0] == -1)
		{
			int best_err = 999999999;
			int best_index = 0;
			for (j = 0; j < 256; j++)
			{
				if (map6[j][0] != -1)
				{
					if ((map6[j][2] - i)*(map6[j][2] - i) < best_err)
					{
						best_err = (map6[j][2] - i)*(map6[j][2] - i);
						best_index = j;
					}
				}
			}
			out_map6[i][0] = map6[best_index][0];
			out_map6[i][1] = map6[best_index][1];
			out_map6[i][2] = map6[best_index][2];
		}
		else
		{
			out_map6[i][0] = map6[i][0];
			out_map6[i][1] = map6[i][1];
			out_map6[i][2] = map6[i][2];
		}
	}
	for (i = 0; i < 256; i++)
		printf("{%2i, %2i, %3i}%s\n", out_map5[i][0], out_map5[i][1], out_map5[i][2], i == 255 ? "" : ",");
	printf("\n");
	for (i = 0; i < 256; i++)
		printf("{%2i, %2i, %3i}%s\n", out_map6[i][0], out_map6[i][1], out_map6[i][2], i == 255 ? "" : ",");
	printf("\n");










	for (i = 0; i < 256; i++)
	{
		if (map5_index2[i][0] == -1)
		{
			int best_err = 999999999;
			int best_index = 0;
			for (j = 0; j < 256; j++)
			{
				if (map5_index2[j][0] != -1)
				{
					if ((map5_index2[j][2] - i)*(map5_index2[j][2] - i) < best_err)
					{
						best_err = (map5_index2[j][2] - i)*(map5_index2[j][2] - i);
						best_index = j;
					}
				}
			}
			out_map5[i][0] = map5_index2[best_index][0];
			out_map5[i][1] = map5_index2[best_index][1];
			out_map5[i][2] = map5_index2[best_index][2];
		}
		else
		{
			out_map5[i][0] = map5_index2[i][0];
			out_map5[i][1] = map5_index2[i][1];
			out_map5[i][2] = map5_index2[i][2];
		}
		if (map6_index2[i][0] == -1)
		{
			int best_err = 999999999;
			int best_index = 0;
			for (j = 0; j < 256; j++)
			{
				if (map6_index2[j][0] != -1)
				{
					if ((map6_index2[j][2] - i)*(map6_index2[j][2] - i) < best_err)
					{
						best_err = (map6_index2[j][2] - i)*(map6_index2[j][2] - i);
						best_index = j;
					}
				}
			}
			out_map6[i][0] = map6_index2[best_index][0];
			out_map6[i][1] = map6_index2[best_index][1];
			out_map6[i][2] = map6_index2[best_index][2];
		}
		else
		{
			out_map6[i][0] = map6_index2[i][0];
			out_map6[i][1] = map6_index2[i][1];
			out_map6[i][2] = map6_index2[i][2];
		}
	}
	for (i = 0; i < 256; i++)
		printf("{%2i, %2i, %3i}%s\n", out_map5[i][0], out_map5[i][1], out_map5[i][2], i == 255 ? "" : ",");
	printf("\n");
	for (i = 0; i < 256; i++)
		printf("{%2i, %2i, %3i}%s\n", out_map6[i][0], out_map6[i][1], out_map6[i][2], i == 255 ? "" : ",");
	printf("\n");

	exit(0);
}

void DDS_ComputeMapsFull()
{
	int *map5initial;
	int *map5;
	int *map6initial;
	int *map6;
	int i;
	int j;
	int out_map5[256][3];
	int out_map6[256][3];
	int *final_map5[3];
	int *final_map6[3];
	int mode;
	char *mode_name[] = {"bestfit5map_index2", "bestfit5map_index3", "bestfit5map_alpha_index2"};
	int counts[3] = {0};
	int current;
	return;

	map5initial = Mem_Malloc(sizeof(int) * 3 * 32 * 32);
	map5 = Mem_Malloc(sizeof(int) * 3 * 256);
	map6initial = Mem_Malloc(sizeof(int) * 3 * 64 * 64);
	map6 = Mem_Malloc(sizeof(int) * 3 * 256);
	
	final_map5[0] = Mem_Malloc(sizeof(int) * 5 * 256);
	final_map5[1] = Mem_Malloc(sizeof(int) * 5 * 256);
	final_map5[2] = Mem_Malloc(sizeof(int) * 5 * 256);
	final_map6[0] = Mem_Malloc(sizeof(int) * 5 * 256);
	final_map6[1] = Mem_Malloc(sizeof(int) * 5 * 256);
	final_map6[2] = Mem_Malloc(sizeof(int) * 5 * 256);

	for (mode = 0; mode < 3; mode++)
	{
		for (i = 0; i < 32 * 32 * 3; i++)
		{
			map5initial[i] = -1;
			map6initial[i] = -1;
		}
		for (i = 0; i < 256; i++)
		{
			map5[i*3 + 0] = -1;
			map5[i*3 + 1] = -1;
			map5[i*3 + 2] = i;
			map6[i*3 + 0] = -1;
			map6[i*3 + 1] = -1;
			map6[i*3 + 2] = i;
		}

		for (i = 0; i < 32; i++)
			for (j = 0; j < 32; j++)
			{
				int start;
				int end;
				int c0;

				start = (i << 3) | (i >> 2);
				end = (j << 3) | (j >> 2);
				if (mode == 0)
					c0 = (int)floorf(start + (end - start) / 3.0f + 0.5f);
				else if (mode == 1)
					c0 = (int)floorf(start + 2.0 * (end - start) / 3.0f + 0.5f);
				else
					c0 = (int)floorf(start + (end - start) / 2.0f + 0.5f);

				map5initial[(i*32 + j)*3 + 0] = i;
				map5initial[(i*32 + j)*3 + 1] = j;
				map5initial[(i*32 + j)*3 + 2] = c0;
			}

		for (i = 0; i < 32 * 32; i++)
		{
			int start = map5initial[i*3 + 0];
			int end = map5initial[i*3 + 1];
			int c0 = map5initial[i*3 + 2];

			int is_correctly_ordered;

			if (mode == 0)
				is_correctly_ordered = end >= start;
			else if (mode == 1)
				is_correctly_ordered = end >= start;
			else if (mode == 2)
				is_correctly_ordered = end <= start;

			if (map5[c0*3 + 0] == -1 && is_correctly_ordered)
			{
				map5[c0*3 + 0] = start;
				map5[c0*3 + 1] = end;
			}
			else
			{
				int len_saved = (map5[c0*3 + 0] - map5[c0*3 + 1])*(map5[c0*3 + 0] - map5[c0*3 + 1]);
				int len_new = (start - end)*(start - end);
				if (len_new < len_saved && is_correctly_ordered)
				{
					//printf("%i %i < %i %i for %i\n", start, end, map5[c0*2 + 0], map5[c0*2 + 1], c0);
					map5[c0*3 + 0] = start;
					map5[c0*3 + 1] = end;
				}
			}
		}

		for (i = 0; i < 64; i++)
			for (j = 0; j < 64; j++)
			{
				int start;
				int end;
				int c0;

				start = (i << 2) | (i >> 4);
				end = (j << 2) | (j >> 4);
				if (mode == 0)
					c0 = (int)floorf(start + (end - start) / 3.0f + 0.5f);
				else if (mode == 1)
					c0 = (int)floorf(start + 2.0 * (end - start) / 3.0f + 0.5f);
				else
					c0 = (int)floorf(start + (end - start) / 2.0f + 0.5f);

				map6initial[(i*64 + j)*3 + 0] = i;
				map6initial[(i*64 + j)*3 + 1] = j;
				map6initial[(i*64 + j)*3 + 2] = c0;
			}

		for (i = 0; i < 64 * 64; i++)
		{
			int start = map6initial[i*3 + 0];
			int end = map6initial[i*3 + 1];
			int c0 = map6initial[i*3 + 2];
			int is_correctly_ordered;

			if (mode == 0)
				is_correctly_ordered = end >= start;
			else if (mode == 1)
				is_correctly_ordered = end >= start;
			else if (mode == 2)
				is_correctly_ordered = end <= start;

			if (map6[c0*3 + 0] == -1 && is_correctly_ordered)
			{
				map6[c0*3 + 0] = start;
				map6[c0*3 + 1] = end;
			}
			else
			{
				int len_saved = (map6[c0*3 + 0] - map6[c0*3 + 1])*(map6[c0*3 + 0] - map6[c0*3 + 1]);
				int len_new = (start - end)*(start - end);
				if (len_new < len_saved && is_correctly_ordered)
				{
					//printf("%i %i < %i %i for %i\n", start, end, map6[c0*2 + 0], map6[c0*2 + 1], c0);
					map6[c0*3 + 0] = start;
					map6[c0*3 + 1] = end;
				}
			}
		}


		for (i = 0; i < 256; i++)
		{
			if (map5[i*3 + 0] == -1)
			{
				int best_err = 999999999;
				int best_index = 0;
				for (j = 0; j < 256; j++)
				{
					if (map5[j*3 + 0] != -1)
					{
						if ((map5[j*3 + 2] - i)*(map5[j*3 + 2] - i) < best_err)
						{
							best_err = (map5[j*3 + 2] - i)*(map5[j*3 + 2] - i);
							best_index = j;
						}
					}
				}
				out_map5[i][0] = map5[best_index*3 + 0];
				out_map5[i][1] = map5[best_index*3 + 1];
				out_map5[i][2] = map5[best_index*3 + 2];
			}
			else
			{
				out_map5[i][0] = map5[i*3 + 0];
				out_map5[i][1] = map5[i*3 + 1];
				out_map5[i][2] = map5[i*3 + 2];
			}
			if (map6[i*3 + 0] == -1)
			{
				int best_err = 999999999;
				int best_index = 0;
				for (j = 0; j < 256; j++)
				{
					if (map6[j*3 + 0] != -1)
					{
						if ((map6[j*3 + 2] - i)*(map6[j*3 + 2] - i) < best_err)
						{
							best_err = (map6[j*3 + 2] - i)*(map6[j*3 + 2] - i);
							best_index = j;
						}
					}
				}
				out_map6[i][0] = map6[best_index*3 + 0];
				out_map6[i][1] = map6[best_index*3 + 1];
				out_map6[i][2] = map6[best_index*3 + 2];
			}
			else
			{
				out_map6[i][0] = map6[i*3 + 0];
				out_map6[i][1] = map6[i*3 + 1];
				out_map6[i][2] = map6[i*3 + 2];
			}
		}

		for (i = 0; i < 256; i++)
		{
			final_map5[mode][i*5 + 0] = out_map5[i][0];
			final_map5[mode][i*5 + 1] = out_map5[i][1];
			final_map5[mode][i*5 + 2] = 0;
			final_map5[mode][i*5 + 3] = 0;
			final_map5[mode][i*5 + 4] = out_map5[i][2];

			final_map6[mode][i*5 + 0] = out_map6[i][0];
			final_map6[mode][i*5 + 1] = out_map6[i][1];
			final_map6[mode][i*5 + 2] = 0;
			final_map6[mode][i*5 + 3] = 0;
			final_map6[mode][i*5 + 4] = out_map6[i][2];
		}
	}

	for (mode = 0; mode < 3; mode++)
	{
		for (i = 0; i < 256; i++)
		{
			final_map5[mode][i*5 + 2] = i;
			final_map5[mode][i*5 + 3] = i;
			final_map6[mode][i*5 + 2] = i;
			final_map6[mode][i*5 + 3] = i;

			for (j = i - 1; j >= 0; j--)
			{
				if (!((final_map5[mode][j*5 + 0] == final_map5[mode][i*5 + 0]) && (final_map5[mode][j*5 + 1] == final_map5[mode][i*5 + 1])))
				{
					final_map5[mode][i*5 + 2] = j;
					break;
				}
			}
			for (j = i - 1; j >= 0; j--)
			{
				if (!((final_map6[mode][j*5 + 0] == final_map6[mode][i*5 + 0]) && (final_map6[mode][j*5 + 1] == final_map6[mode][i*5 + 1])))
				{
					final_map6[mode][i*5 + 2] = j;
					break;
				}
			}
			for (j = i + 1; j < 256; j++)
			{
				if (!((final_map5[mode][j*5 + 0] == final_map5[mode][i*5 + 0]) && (final_map5[mode][j*5 + 1] == final_map5[mode][i*5 + 1])))
				{
					final_map5[mode][i*5 + 3] = j;
					break;
				}
			}
			for (j = i + 1; j < 256; j++)
			{
				if (!((final_map6[mode][j*5 + 0] == final_map6[mode][i*5 + 0]) && (final_map6[mode][j*5 + 1] == final_map6[mode][i*5 + 1])))
				{
					final_map6[mode][i*5 + 3] = j;
					break;
				}
			}
		}
	}
	/*
	for (i = 0; i < 256; i++)
		printf("{%2i, %2i, %3i}%s\n", map5[i*2 + 0], map5[i*2 + 1], i, i == 255 ? "" : ",");
	printf("\n");
	*/
	/*
	printf("static int g_dds_bestfitmap5[256][3][2] = \n");
	printf("{\n");
	for (i = 0; i < 256; i++)
	{
		printf("     {{%2i, %2i, %3i}, {%2i, %2i, %3i}, {%2i, %2i, %3i}}%s\n", final_map5[0][i*3 + 0], final_map5[0][i*3 + 1], final_map5[0][i*3 + 2], final_map5[1][i*3 + 0], final_map5[1][i*3 + 1], final_map5[1][i*3 + 2], final_map5[2][i*3 + 0], final_map5[2][i*3 + 1], final_map5[2][i*3 + 2], i != 256 ? "," : "");
	}
	printf("};\n");
	printf("static int g_dds_bestfitmap6[256][3][2] = \n");
	printf("{\n");
	for (i = 0; i < 256; i++)
	{
		printf("     {{%2i, %2i, %3i}, {%2i, %2i, %3i}, {%2i, %2i, %3i}}%s\n", final_map6[0][i*3 + 0], final_map6[0][i*3 + 1], final_map6[0][i*3 + 2], final_map6[1][i*3 + 0], final_map6[1][i*3 + 1], final_map6[1][i*3 + 2], final_map6[2][i*3 + 0], final_map6[2][i*3 + 1], final_map6[2][i*3 + 2], i != 256 ? "," : "");
	}
	printf("};\n");
*/
#if 0
	printf("// endpoint pairs to colour map assuming index 2. For index 3, flip order of the endpoints.\n");
	printf("// entry 0 is endpoint 0.\n");
	printf("// entry 1 is endpoint 1.\n");
	printf("// entry 2 is the index of the next closest colour < the current colour. If there is no colour < the current colour, this will equal the current index.\n");
	printf("// entry 3 is the index of the next closest colour > the current colour. If there is no colour > the current colour, this will equal the current index.\n");
	printf("static int g_dds_bestfitmap5[256][3][4] = \n");
	printf("{\n");
	for (i = 0; i < 256; i++)
	{
		printf("     {{%2i, %2i, %3i, %3i} /* colour %3i, closest below %3i, closest above %3i */, {%2i, %2i, %3i, %3i}  /* colour %3i, closest below %3i, closest above %3i */, {%2i, %2i, %3i, %3i}  /* colour %3i, closest below %3i, closest above %3i */}%s // index %3i\n", 
			final_map5[0][i*5 + 0], final_map5[0][i*5 + 1], final_map5[0][i*5 + 2], final_map5[0][i*5 + 3], 
			final_map5[0][i*5 + 4], final_map5[0][final_map5[0][i*5 + 2]*5 + 4], final_map5[0][final_map5[0][i*5 + 3]*5 + 4],
			final_map5[1][i*5 + 0], final_map5[1][i*5 + 1], final_map5[1][i*5 + 2], final_map5[1][i*5 + 3], 
			final_map5[1][i*5 + 4], final_map5[1][final_map5[1][i*5 + 2]*5 + 4], final_map5[1][final_map5[1][i*5 + 3]*5 + 4],
			final_map5[2][i*5 + 0], final_map5[2][i*5 + 1], final_map5[2][i*5 + 2], final_map5[2][i*5 + 3], 
			final_map5[2][i*5 + 4], final_map5[2][final_map5[2][i*5 + 2]*5 + 4], final_map5[2][final_map5[2][i*5 + 3]*5 + 4],
			i != 255 ? "," : " ", 
			i);
	}
	printf("};\n");
	printf("// endpoint pairs to colour map assuming index 2. For index 3, flip order of the endpoints.\n");
	printf("// entry 0 is endpoint 0.\n");
	printf("// entry 1 is endpoint 1.\n");
	printf("// entry 2 is the index of the next closest colour < the current colour. If there is no colour < the current colour, this will equal the current index.\n");
	printf("// entry 3 is the index of the next closest colour > the current colour. If there is no colour > the current colour, this will equal the current index.\n");
	printf("static int g_dds_bestfitmap6[256][3][4] = \n");
	printf("{\n");
	for (i = 0; i < 256; i++)
	{
		printf("     {{%2i, %2i, %3i, %3i} /* colour %3i, closest below %3i, closest above %3i */, {%2i, %2i, %3i, %3i}  /* colour %3i, closest below %3i, closest above %3i */, {%2i, %2i, %3i, %3i}  /* colour %3i, closest below %3i, closest above %3i */}%s // index %3i\n", 
			final_map6[0][i*5 + 0], final_map6[0][i*5 + 1], final_map6[0][i*5 + 2], final_map6[0][i*5 + 3], 
			final_map6[0][i*5 + 4], final_map6[0][final_map6[0][i*5 + 2]*5 + 4], final_map6[0][final_map6[0][i*5 + 3]*5 + 4],
			final_map6[1][i*5 + 0], final_map6[1][i*5 + 1], final_map6[1][i*5 + 2], final_map6[1][i*5 + 3], 
			final_map6[1][i*5 + 4], final_map6[1][final_map6[1][i*5 + 2]*5 + 4], final_map6[1][final_map6[1][i*5 + 3]*5 + 4],
			final_map6[2][i*5 + 0], final_map6[2][i*5 + 1], final_map6[2][i*5 + 2], final_map6[2][i*5 + 3], 
			final_map6[2][i*5 + 4], final_map6[2][final_map6[2][i*5 + 2]*5 + 4], final_map6[2][final_map6[2][i*5 + 3]*5 + 4],
			i != 255 ? "," : " ", 
			i);
	}
	printf("};\n");

	for (j = 0; j < 3; j++)
	{
		int counts = 1;
		current = 0;
		for (i = 1; i < 256; i++)
		{
			if (final_map5[j][i*5 + 4] != final_map5[j][current*5 + 4])
			{
				current = i;
				counts++;
			}
		}
		printf("COUNTS MAP 5 %i: %3i\n", j, counts);
	}
	for (j = 0; j < 3; j++)
	{
		int counts = 1;
		current = 0;
		for (i = 1; i < 256; i++)
		{
			if (final_map6[j][i*5 + 4] != final_map6[j][current*5 + 4])
			{
				current = i;
				counts++;
			}
		}
		printf("COUNTS MAP 6 %i: %3i\n", j, counts);
	}
#endif








	for (mode = 0; mode < 3; mode++)
	{
		for (i = 0; i < 32 * 32 * 3; i++)
		{
			map5initial[i] = -1;
			map6initial[i] = -1;
		}
		for (i = 0; i < 256; i++)
		{
			map5[i*3 + 0] = -1;
			map5[i*3 + 1] = -1;
			map5[i*3 + 2] = i;
			map6[i*3 + 0] = -1;
			map6[i*3 + 1] = -1;
			map6[i*3 + 2] = i;
		}

		for (i = 0; i < 32; i++)
			for (j = 0; j < 32; j++)
			{
				int start;
				int end;
				int c0;

				start = (i << 3) | (i >> 2);
				end = (j << 3) | (j >> 2);
				if (mode == 0)
					c0 = (int)floorf(start + (end - start) / 3.0f + 0.5f);
				else if (mode == 1)
					c0 = (int)floorf(start + 2.0 * (end - start) / 3.0f + 0.5f);
				else
					c0 = (int)floorf(start + (end - start) / 2.0f + 0.5f);

				map5initial[(i*32 + j)*3 + 0] = i;
				map5initial[(i*32 + j)*3 + 1] = j;
				map5initial[(i*32 + j)*3 + 2] = c0;
			}

		for (i = 0; i < 32 * 32; i++)
		{
			int start = map5initial[i*3 + 0];
			int end = map5initial[i*3 + 1];
			int c0 = map5initial[i*3 + 2];
			int is_correctly_ordered = 1;

			if (map5[c0*3 + 0] == -1 && is_correctly_ordered)
			{
				map5[c0*3 + 0] = start;
				map5[c0*3 + 1] = end;
			}
			else
			{
				int len_saved = (map5[c0*3 + 0] - map5[c0*3 + 1])*(map5[c0*3 + 0] - map5[c0*3 + 1]);
				int len_new = (start - end)*(start - end);
				if (len_new < len_saved && is_correctly_ordered)
				{
					//printf("%i %i < %i %i for %i\n", start, end, map5[c0*2 + 0], map5[c0*2 + 1], c0);
					map5[c0*3 + 0] = start;
					map5[c0*3 + 1] = end;
				}
			}
		}

		for (i = 0; i < 64; i++)
			for (j = 0; j < 64; j++)
			{
				int start;
				int end;
				int c0;

				start = (i << 2) | (i >> 4);
				end = (j << 2) | (j >> 4);
				if (mode == 0)
					c0 = (int)floorf(start + (end - start) / 3.0f + 0.5f);
				else if (mode == 1)
					c0 = (int)floorf(start + 2.0 * (end - start) / 3.0f + 0.5f);
				else
					c0 = (int)floorf(start + (end - start) / 2.0f + 0.5f);

				map6initial[(i*64 + j)*3 + 0] = i;
				map6initial[(i*64 + j)*3 + 1] = j;
				map6initial[(i*64 + j)*3 + 2] = c0;
			}

		for (i = 0; i < 64 * 64; i++)
		{
			int start = map6initial[i*3 + 0];
			int end = map6initial[i*3 + 1];
			int c0 = map6initial[i*3 + 2];
			int is_correctly_ordered = 1;

			if (map6[c0*3 + 0] == -1 && is_correctly_ordered)
			{
				map6[c0*3 + 0] = start;
				map6[c0*3 + 1] = end;
			}
			else
			{
				int len_saved = (map6[c0*3 + 0] - map6[c0*3 + 1])*(map6[c0*3 + 0] - map6[c0*3 + 1]);
				int len_new = (start - end)*(start - end);
				if (len_new < len_saved && is_correctly_ordered)
				{
					//printf("%i %i < %i %i for %i\n", start, end, map6[c0*2 + 0], map6[c0*2 + 1], c0);
					map6[c0*3 + 0] = start;
					map6[c0*3 + 1] = end;
				}
			}
		}


		for (i = 0; i < 256; i++)
		{
			if (map5[i*3 + 0] == -1)
			{
				int best_err = 999999999;
				int best_index = 0;
				for (j = 0; j < 256; j++)
				{
					if (map5[j*3 + 0] != -1)
					{
						if ((map5[j*3 + 2] - i)*(map5[j*3 + 2] - i) < best_err)
						{
							best_err = (map5[j*3 + 2] - i)*(map5[j*3 + 2] - i);
							best_index = j;
						}
					}
				}
				out_map5[i][0] = map5[best_index*3 + 0];
				out_map5[i][1] = map5[best_index*3 + 1];
				out_map5[i][2] = map5[best_index*3 + 2];
			}
			else
			{
				out_map5[i][0] = map5[i*3 + 0];
				out_map5[i][1] = map5[i*3 + 1];
				out_map5[i][2] = map5[i*3 + 2];
			}
			if (map6[i*3 + 0] == -1)
			{
				int best_err = 999999999;
				int best_index = 0;
				for (j = 0; j < 256; j++)
				{
					if (map6[j*3 + 0] != -1)
					{
						if ((map6[j*3 + 2] - i)*(map6[j*3 + 2] - i) < best_err)
						{
							best_err = (map6[j*3 + 2] - i)*(map6[j*3 + 2] - i);
							best_index = j;
						}
					}
				}
				out_map6[i][0] = map6[best_index*3 + 0];
				out_map6[i][1] = map6[best_index*3 + 1];
				out_map6[i][2] = map6[best_index*3 + 2];
			}
			else
			{
				out_map6[i][0] = map6[i*3 + 0];
				out_map6[i][1] = map6[i*3 + 1];
				out_map6[i][2] = map6[i*3 + 2];
			}
		}

		for (i = 0; i < 256; i++)
		{
			final_map5[mode][i*5 + 0] = out_map5[i][0];
			final_map5[mode][i*5 + 1] = out_map5[i][1];
			final_map5[mode][i*5 + 2] = 0;
			final_map5[mode][i*5 + 3] = 0;
			final_map5[mode][i*5 + 4] = out_map5[i][2];

			final_map6[mode][i*5 + 0] = out_map6[i][0];
			final_map6[mode][i*5 + 1] = out_map6[i][1];
			final_map6[mode][i*5 + 2] = 0;
			final_map6[mode][i*5 + 3] = 0;
			final_map6[mode][i*5 + 4] = out_map6[i][2];
		}
	}

	for (mode = 0; mode < 3; mode++)
	{
		for (i = 0; i < 256; i++)
		{
			final_map5[mode][i*5 + 2] = i;
			final_map5[mode][i*5 + 3] = i;
			final_map6[mode][i*5 + 2] = i;
			final_map6[mode][i*5 + 3] = i;

			for (j = i - 1; j >= 0; j--)
			{
				if (!((final_map5[mode][j*5 + 0] == final_map5[mode][i*5 + 0]) && (final_map5[mode][j*5 + 1] == final_map5[mode][i*5 + 1])))
				{
					final_map5[mode][i*5 + 2] = j;
					break;
				}
			}
			for (j = i - 1; j >= 0; j--)
			{
				if (!((final_map6[mode][j*5 + 0] == final_map6[mode][i*5 + 0]) && (final_map6[mode][j*5 + 1] == final_map6[mode][i*5 + 1])))
				{
					final_map6[mode][i*5 + 2] = j;
					break;
				}
			}
			for (j = i + 1; j < 256; j++)
			{
				if (!((final_map5[mode][j*5 + 0] == final_map5[mode][i*5 + 0]) && (final_map5[mode][j*5 + 1] == final_map5[mode][i*5 + 1])))
				{
					final_map5[mode][i*5 + 3] = j;
					break;
				}
			}
			for (j = i + 1; j < 256; j++)
			{
				if (!((final_map6[mode][j*5 + 0] == final_map6[mode][i*5 + 0]) && (final_map6[mode][j*5 + 1] == final_map6[mode][i*5 + 1])))
				{
					final_map6[mode][i*5 + 3] = j;
					break;
				}
			}
		}
	}

	printf("// endpoint pairs to colour map assuming index 2. For index 3, flip order of the endpoints.\n");
	printf("// entry 0 is endpoint 0.\n");
	printf("// entry 1 is endpoint 1.\n");
	printf("// entry 2 is the index of the next closest colour < the current colour. If there is no colour < the current colour, this will equal the current index.\n");
	printf("// entry 3 is the index of the next closest colour > the current colour. If there is no colour > the current colour, this will equal the current index.\n");
	printf("static int g_dds_bestfitmap5[256][2][4] = \n");
	printf("{\n");
	for (i = 0; i < 256; i++)
	{
		printf("     {{%2i, %2i, %3i, %3i} /* colour %3i, closest below %3i, closest above %3i */, {%2i, %2i, %3i, %3i}  /* colour %3i, closest below %3i, closest above %3i */}%s // index %3i\n", 
			final_map5[0][i*5 + 0], final_map5[0][i*5 + 1], final_map5[0][i*5 + 2], final_map5[0][i*5 + 3], 
			final_map5[0][i*5 + 4], final_map5[0][final_map5[0][i*5 + 2]*5 + 4], final_map5[0][final_map5[0][i*5 + 3]*5 + 4],
			final_map5[2][i*5 + 0], final_map5[2][i*5 + 1], final_map5[2][i*5 + 2], final_map5[2][i*5 + 3], 
			final_map5[2][i*5 + 4], final_map5[2][final_map5[2][i*5 + 2]*5 + 4], final_map5[2][final_map5[2][i*5 + 3]*5 + 4],
			i != 255 ? "," : " ", 
			i);
	}
	printf("};\n");
	printf("// endpoint pairs to colour map assuming index 2. For index 3, flip order of the endpoints.\n");
	printf("// entry 0 is endpoint 0.\n");
	printf("// entry 1 is endpoint 1.\n");
	printf("// entry 2 is the index of the next closest colour < the current colour. If there is no colour < the current colour, this will equal the current index.\n");
	printf("// entry 3 is the index of the next closest colour > the current colour. If there is no colour > the current colour, this will equal the current index.\n");
	printf("static int g_dds_bestfitmap6[256][2][4] = \n");
	printf("{\n");
	for (i = 0; i < 256; i++)
	{
		printf("     {{%2i, %2i, %3i, %3i} /* colour %3i, closest below %3i, closest above %3i */, {%2i, %2i, %3i, %3i}  /* colour %3i, closest below %3i, closest above %3i */}%s // index %3i\n", 
			final_map6[0][i*5 + 0], final_map6[0][i*5 + 1], final_map6[0][i*5 + 2], final_map6[0][i*5 + 3], 
			final_map6[0][i*5 + 4], final_map6[0][final_map6[0][i*5 + 2]*5 + 4], final_map6[0][final_map6[0][i*5 + 3]*5 + 4],
			final_map6[2][i*5 + 0], final_map6[2][i*5 + 1], final_map6[2][i*5 + 2], final_map6[2][i*5 + 3], 
			final_map6[2][i*5 + 4], final_map6[2][final_map6[2][i*5 + 2]*5 + 4], final_map6[2][final_map6[2][i*5 + 3]*5 + 4],
			i != 255 ? "," : " ", 
			i);
	}
	printf("};\n");

	for (j = 0; j < 3; j++)
	{
		int counts = 1;
		current = 0;
		for (i = 1; i < 256; i++)
		{
			if (final_map5[j][i*5 + 4] != final_map5[j][current*5 + 4])
			{
				current = i;
				counts++;
			}
		}
		printf("COUNTS MAP 5 %i: %3i\n", j, counts);
	}
	for (j = 0; j < 3; j++)
	{
		int counts = 1;
		current = 0;
		for (i = 1; i < 256; i++)
		{
			if (final_map6[j][i*5 + 4] != final_map6[j][current*5 + 4])
			{
				current = i;
				counts++;
			}
		}
		printf("COUNTS MAP 6 %i: %3i\n", j, counts);
	}




	exit(0);
}

int DDS_SphereTestCompare(void *arg0, void *arg1)
{
	if (*(int*)arg0 < *(int*)arg1)
		return -1;
	else if (*(int*)arg0 > *(int*)arg1)
		return 1;
	else
		return 0;
}

void DDS_SphereTest()
{
	return;
	if(1)
	{
		int i;
		int r,g,b,m;
		int source[3];
		int target[3];
		int count = 0;
		int index_count[2][512] = {0};
		int index_mapping[11*11*11*2];
		memset(index_mapping, -1, sizeof(int)*11*11*11*2);

		for (r = -5; r <= 5; r++)
			for (g = -5; g <= 5; g++)
				for (b = -5; b <= 5; b++)
				{
					int found = 0;
					source[0] = r;
					source[1] = g;
					source[2] = b;
					for (m = 0; m < DDS_HALF_SPHERE_MAP_NUM_INDEXES; m++)
					{
						if ((source[0] == g_dds_half_sphere_map[m][0]) && (source[1] == g_dds_half_sphere_map[m][1]) && (source[2] == g_dds_half_sphere_map[m][2]))
						{
							found = 1;
							printf("mapping %4i: %3i %3i %3i at index %3i, swap 0\n", count, source[0], source[1], source[2], m);
							index_count[0][m]++;
							index_mapping[(r+5)*11*11*2 + (g+5)*11*2 + (b+5)*2 + 0] = m;
							index_mapping[(r+5)*11*11*2 + (g+5)*11*2 + (b+5)*2 + 1] = 0;
							count++;
						}
					}
					if (found)
						continue;
					source[0] = -source[0];
					source[1] = -source[1];
					source[2] = -source[2];
					for (m = 0; m < DDS_HALF_SPHERE_MAP_NUM_INDEXES; m++)
					{
						if ((source[0] == g_dds_half_sphere_map[m][0]) && (source[1] == g_dds_half_sphere_map[m][1]) && (source[2] == g_dds_half_sphere_map[m][2]))
						{
							found = 1;
							printf("mapping %4i: %3i %3i %3i at index %3i, swap 1\n", count, -source[0], -source[1], -source[2], m);
							index_count[1][m]++;
							index_mapping[(r+5)*11*11*2 + (g+5)*11*2 + (b+5)*2 + 0] = m;
							index_mapping[(r+5)*11*11*2 + (g+5)*11*2 + (b+5)*2 + 1] = 1;
							count++;
						}
					}
				}

		for (r = -5; r <= 5; r++)
			for (g = -5; g <= 5; g++)
				for (b = -5; b <= 5; b++)
				{
					printf("{%3i, %i}, // %2i, %2i, %2i\n", index_mapping[(r+5)*11*11*2 + (g+5)*11*2 + (b+5)*2 + 0], index_mapping[(r+5)*11*11*2 + (g+5)*11*2 + (b+5)*2 + 1], r, g, b);
				}
		/*
		for (i = 0; i < 256; i++)
			printf("index %3i: %i %i\n", i, index_count[0][i], index_count[1][i]);
		printf("index 105: %2i %2i %2i\n", g_dds_half_sphere_map[105][0], g_dds_half_sphere_map[105][1], g_dds_half_sphere_map[105][2]);
		*/
		exit(0);
	}


	{
		int *counts = Mem_Malloc((1 << 24) * sizeof(int));
		int **attached = Mem_Malloc((1 << 24) * sizeof(int*));
		int *attached_counts = Mem_Malloc((1 << 24) * sizeof(int));
		int side_length = 1 << 8;
		int i, j, k, m;
		memset(counts, 0, (1 << 24) * sizeof(int));
		memset(attached, 0, (1 << 24) * sizeof(int*));

		printf("allocated %.2fMB\n", (1 << 24) * sizeof(int) / 1048576.0f);
		printf("allocated %.2fMB\n", (1 << 24) * sizeof(int*) / 1048576.0f);

		int mins = 128 - 8;
		int maxs = 128 + 8;
		for (i = mins; i <= maxs; i++)
			for (j = mins; j <= maxs; j++)
				for (k = mins; k <= maxs; k++)
					for (m = 0; m < DDS_HALF_SPHERE_MAP_NUM_INDEXES; m++)
					{
						int local_count;
						int x_off = i + g_dds_half_sphere_map[m][0];
						int y_off = j + g_dds_half_sphere_map[m][1];
						int z_off = k + g_dds_half_sphere_map[m][2];

						if (x_off < 0 || x_off > 255)
							continue;
						if (y_off < 0 || y_off > 255)
							continue;
						if (z_off < 0 || z_off > 255)
							continue;

						counts[z_off * side_length * side_length + y_off * side_length + x_off]++;

						attached_counts[z_off * side_length * side_length + y_off * side_length + x_off]++;
						if (attached[z_off * side_length * side_length + y_off * side_length + x_off] == 0)
						{
							attached[z_off * side_length * side_length + y_off * side_length + x_off] = Mem_Malloc(sizeof(int) * 4096);
							memset(attached[z_off * side_length * side_length + y_off * side_length + x_off], 0, sizeof(int) * 4096);
						}
						attached[z_off * side_length * side_length + y_off * side_length + x_off][attached_counts[z_off * side_length * side_length + y_off * side_length + x_off] - 1] = (i << 16) | (j << 8) | (k << 0);
						if (x_off == 128 && y_off == 128 && z_off == 128)
						{
							int m = attached_counts[z_off * side_length * side_length + y_off * side_length + x_off] - 1;
							printf("%5ith attachment to %3i, %3i, %3i\n", m + 1, (attached[z_off * side_length * side_length + y_off * side_length + x_off][m] >> 16) & 0xFF, (attached[z_off * side_length * side_length + y_off * side_length + x_off][m] >> 8) & 0xFF, (attached[z_off * side_length * side_length + y_off * side_length + x_off][m] >> 0) & 0xFF);
						}

						if (!((i == x_off) && (j == y_off) && (k == z_off)))
						{
							attached_counts[k * side_length * side_length + j * side_length + i]++;
							if (attached[k * side_length * side_length + j * side_length + i] == 0)
							{
								attached[k * side_length * side_length + j * side_length + i] = Mem_Malloc(sizeof(int) * 4096);
								memset(attached[k * side_length * side_length + j * side_length + i], 0, sizeof(int) * 4096);
							}
							attached[k * side_length * side_length + j * side_length + i][attached_counts[k * side_length * side_length + j * side_length + i] - 1] = (x_off << 16) | (y_off << 8) | (z_off << 0);

							if (i == 128 && j == 128 && k == 128)
							{
								int m = attached_counts[k * side_length * side_length + j * side_length + i] - 1;
								printf("%5ith attachment to %3i, %3i, %3i\n", m + 1, (attached[k * side_length * side_length + j * side_length + i][m] >> 16) & 0xFF, (attached[k * side_length * side_length + j * side_length + i][m] >> 8) & 0xFF, (attached[k * side_length * side_length + j * side_length + i][m] >> 0) & 0xFF);
							}
						}
					}

		for (i = 128; i < 128 + 4; i++)
			for (j = 128; j < 128 + 4; j++)
				for (k = 128; k < 128 + 4; k++)
					printf("counts %3i %3i %3i: %i\n", i, j, k, counts[i*side_length*side_length + j*side_length + k]);

		for (i = 128; i < 128 + 1; i++)
			for (j = 128; j < 128 + 1; j++)
				for (k = 128; k < 128 + 1; k++)
					for (int m = 0; m < attached_counts[k * side_length * side_length + j * side_length + i]; m++)
						printf("%5ith attachment to %3i, %3i, %3i (0x%08X)\n", m + 1, (attached[k * side_length * side_length + j * side_length + i][m] >> 16) & 0xFF, (attached[k * side_length * side_length + j * side_length + i][m] >> 8) & 0xFF, (attached[k * side_length * side_length + j * side_length + i][m] >> 0) & 0xFF, attached[k * side_length * side_length + j * side_length + i][m]);

		qsort(attached[128 * side_length * side_length + 128 * side_length + 128], attached_counts[128 * side_length * side_length + 128 * side_length + 128], sizeof(int), DDS_SphereTestCompare);

		for (i = 128; i < 128 + 1; i++)
			for (j = 128; j < 128 + 1; j++)
				for (k = 128; k < 128 + 1; k++)
					for (int m = 0; m < attached_counts[k * side_length * side_length + j * side_length + i]; m++)
					{
						int same_count = 0;
						for (int p = 0; p < attached_counts[k * side_length * side_length + j * side_length + i]; p++)
							if (attached[k * side_length * side_length + j * side_length + i][m] == attached[k * side_length * side_length + j * side_length + i][p])
								same_count++;

						printf("Sorted %5ith attachment to %3i, %3i, %3i (0x%08X), %i duplicates\n", m + 1, (attached[k * side_length * side_length + j * side_length + i][m] >> 16) & 0xFF, (attached[k * side_length * side_length + j * side_length + i][m] >> 8) & 0xFF, (attached[k * side_length * side_length + j * side_length + i][m] >> 0) & 0xFF, attached[k * side_length * side_length + j * side_length + i][m], same_count - 1);
					}

		exit(0);
	}
}
#endif